/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 773:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

eval("\n// EXTERNAL MODULE: ./node_modules/workbox-core/_version.js\nvar _version = __webpack_require__(913);\n;// CONCATENATED MODULE: ./node_modules/workbox-core/_private/Deferred.js\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nclass Deferred {\n    /**\n     * Creates a promise and exposes its resolve and reject functions as methods.\n     */\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\n\n;// CONCATENATED MODULE: ./node_modules/workbox-core/_private/dontWaitFor.js\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\nfunction dontWaitFor(promise) {\n    // Effective no-op.\n    void promise.then(() => { });\n}\n\n;// CONCATENATED MODULE: ./node_modules/workbox-core/_private/logger.js\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst logger = ( true\n    ? null\n    : 0);\n\n\n// EXTERNAL MODULE: ./node_modules/workbox-window/_version.js\nvar workbox_window_version = __webpack_require__(317);\n;// CONCATENATED MODULE: ./node_modules/workbox-window/messageSW.js\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * Sends a data object to a service worker via `postMessage` and resolves with\n * a response (if any).\n *\n * A response can be set in a message handler in the service worker by\n * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n * returned by `messageSW()`. If no response is set, the promise will not\n * resolve.\n *\n * @param {ServiceWorker} sw The service worker to send the message to.\n * @param {Object} data An object to send to the service worker.\n * @return {Promise<Object|undefined>}\n * @memberof workbox-window\n */\n// Better not change type of data.\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction messageSW(sw, data) {\n    return new Promise((resolve) => {\n        const messageChannel = new MessageChannel();\n        messageChannel.port1.onmessage = (event) => {\n            resolve(event.data);\n        };\n        sw.postMessage(data, [messageChannel.port2]);\n    });\n}\n\n\n;// CONCATENATED MODULE: ./node_modules/workbox-window/utils/WorkboxEventTarget.js\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n/**\n * A minimal `EventTarget` shim.\n * This is necessary because not all browsers support constructable\n * `EventTarget`, so using a real `EventTarget` will error.\n * @private\n */\nclass WorkboxEventTarget {\n    constructor() {\n        this._eventListenerRegistry = new Map();\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n    addEventListener(type, listener) {\n        const foo = this._getEventListenersByType(type);\n        foo.add(listener);\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n    removeEventListener(type, listener) {\n        this._getEventListenersByType(type).delete(listener);\n    }\n    /**\n     * @param {Object} event\n     * @private\n     */\n    dispatchEvent(event) {\n        event.target = this;\n        const listeners = this._getEventListenersByType(event.type);\n        for (const listener of listeners) {\n            listener(event);\n        }\n    }\n    /**\n     * Returns a Set of listeners associated with the passed event type.\n     * If no handlers have been registered, an empty Set is returned.\n     *\n     * @param {string} type The event type.\n     * @return {Set<ListenerCallback>} An array of handler functions.\n     * @private\n     */\n    _getEventListenersByType(type) {\n        if (!this._eventListenerRegistry.has(type)) {\n            this._eventListenerRegistry.set(type, new Set());\n        }\n        return this._eventListenerRegistry.get(type);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/workbox-window/utils/urlsMatch.js\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * Returns true if two URLs have the same `.href` property. The URLS can be\n * relative, and if they are the current location href is used to resolve URLs.\n *\n * @private\n * @param {string} url1\n * @param {string} url2\n * @return {boolean}\n */\nfunction urlsMatch(url1, url2) {\n    const { href } = location;\n    return new URL(url1, href).href === new URL(url2, href).href;\n}\n\n;// CONCATENATED MODULE: ./node_modules/workbox-window/utils/WorkboxEvent.js\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * A minimal `Event` subclass shim.\n * This doesn't *actually* subclass `Event` because not all browsers support\n * constructable `EventTarget`, and using a real `Event` will error.\n * @private\n */\nclass WorkboxEvent {\n    constructor(type, props) {\n        this.type = type;\n        Object.assign(this, props);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/workbox-window/Workbox.js\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n// The de facto standard message that a service worker should be listening for\n// to trigger a call to skipWaiting().\nconst SKIP_WAITING_MESSAGE = { type: 'SKIP_WAITING' };\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires {@link workbox-window.Workbox#message}\n * @fires {@link workbox-window.Workbox#installed}\n * @fires {@link workbox-window.Workbox#waiting}\n * @fires {@link workbox-window.Workbox#controlling}\n * @fires {@link workbox-window.Workbox#activated}\n * @fires {@link workbox-window.Workbox#redundant}\n * @memberof workbox-window\n */\nclass Workbox extends WorkboxEventTarget {\n    /**\n     * Creates a new Workbox instance with a script URL and service worker\n     * options. The script URL and options are the same as those used when\n     * calling [navigator.serviceWorker.register(scriptURL, options)](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register).\n     *\n     * @param {string|TrustedScriptURL} scriptURL The service worker script\n     *     associated with this instance. Using a\n     *     [`TrustedScriptURL`](https://web.dev/trusted-types/) is supported.\n     * @param {Object} [registerOptions] The service worker options associated\n     *     with this instance.\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    constructor(scriptURL, registerOptions = {}) {\n        super();\n        this._registerOptions = {};\n        this._updateFoundCount = 0;\n        // Deferreds we can resolve later.\n        this._swDeferred = new Deferred();\n        this._activeDeferred = new Deferred();\n        this._controllingDeferred = new Deferred();\n        this._registrationTime = 0;\n        this._ownSWs = new Set();\n        /**\n         * @private\n         */\n        this._onUpdateFound = () => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const installingSW = registration.installing;\n            // If the script URL passed to `navigator.serviceWorker.register()` is\n            // different from the current controlling SW's script URL, we know any\n            // successful registration calls will trigger an `updatefound` event.\n            // But if the registered script URL is the same as the current controlling\n            // SW's script URL, we'll only get an `updatefound` event if the file\n            // changed since it was last registered. This can be a problem if the user\n            // opens up the same page in a different tab, and that page registers\n            // a SW that triggers an update. It's a problem because this page has no\n            // good way of knowing whether the `updatefound` event came from the SW\n            // script it registered or from a registration attempt made by a newer\n            // version of the page running in another tab.\n            // To minimize the possibility of a false positive, we use the logic here:\n            const updateLikelyTriggeredExternally = \n            // Since we enforce only calling `register()` once, and since we don't\n            // add the `updatefound` event listener until the `register()` call, if\n            // `_updateFoundCount` is > 0 then it means this method has already\n            // been called, thus this SW must be external\n            this._updateFoundCount > 0 ||\n                // If the script URL of the installing SW is different from this\n                // instance's script URL, we know it's definitely not from our\n                // registration.\n                !urlsMatch(installingSW.scriptURL, this._scriptURL.toString()) ||\n                // If all of the above are false, then we use a time-based heuristic:\n                // Any `updatefound` event that occurs long after our registration is\n                // assumed to be external.\n                performance.now() > this._registrationTime + REGISTRATION_TIMEOUT_DURATION\n                ? // If any of the above are not true, we assume the update was\n                    // triggered by this instance.\n                    true\n                : false;\n            if (updateLikelyTriggeredExternally) {\n                this._externalSW = installingSW;\n                registration.removeEventListener('updatefound', this._onUpdateFound);\n            }\n            else {\n                // If the update was not triggered externally we know the installing\n                // SW is the one we registered, so we set it.\n                this._sw = installingSW;\n                this._ownSWs.add(installingSW);\n                this._swDeferred.resolve(installingSW);\n                // The `installing` state isn't something we have a dedicated\n                // callback for, but we do log messages for it in development.\n                if (false) {}\n            }\n            // Increment the `updatefound` count, so future invocations of this\n            // method can be sure they were triggered externally.\n            ++this._updateFoundCount;\n            // Add a `statechange` listener regardless of whether this update was\n            // triggered externally, since we have callbacks for both.\n            installingSW.addEventListener('statechange', this._onStateChange);\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onStateChange = (originalEvent) => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const sw = originalEvent.target;\n            const { state } = sw;\n            const isExternal = sw === this._externalSW;\n            const eventProps = {\n                sw,\n                isExternal,\n                originalEvent,\n            };\n            if (!isExternal && this._isUpdate) {\n                eventProps.isUpdate = true;\n            }\n            this.dispatchEvent(new WorkboxEvent(state, eventProps));\n            if (state === 'installed') {\n                // This timeout is used to ignore cases where the service worker calls\n                // `skipWaiting()` in the install event, thus moving it directly in the\n                // activating state. (Since all service workers *must* go through the\n                // waiting phase, the only way to detect `skipWaiting()` called in the\n                // install event is to observe that the time spent in the waiting phase\n                // is very short.)\n                // NOTE: we don't need separate timeouts for the own and external SWs\n                // since they can't go through these phases at the same time.\n                this._waitingTimeout = self.setTimeout(() => {\n                    // Ensure the SW is still waiting (it may now be redundant).\n                    if (state === 'installed' && registration.waiting === sw) {\n                        this.dispatchEvent(new WorkboxEvent('waiting', eventProps));\n                        if (false) {}\n                    }\n                }, WAITING_TIMEOUT_DURATION);\n            }\n            else if (state === 'activating') {\n                clearTimeout(this._waitingTimeout);\n                if (!isExternal) {\n                    this._activeDeferred.resolve(sw);\n                }\n            }\n            if (false) {}\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onControllerChange = (originalEvent) => {\n            const sw = this._sw;\n            const isExternal = sw !== navigator.serviceWorker.controller;\n            // Unconditionally dispatch the controlling event, with isExternal set\n            // to distinguish between controller changes due to the initial registration\n            // vs. an update-check or other tab's registration.\n            // See https://github.com/GoogleChrome/workbox/issues/2786\n            this.dispatchEvent(new WorkboxEvent('controlling', {\n                isExternal,\n                originalEvent,\n                sw,\n                isUpdate: this._isUpdate,\n            }));\n            if (!isExternal) {\n                if (false) {}\n                this._controllingDeferred.resolve(sw);\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onMessage = async (originalEvent) => {\n            // Can't change type 'any' of data.\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const { data, ports, source } = originalEvent;\n            // Wait until there's an \"own\" service worker. This is used to buffer\n            // `message` events that may be received prior to calling `register()`.\n            await this.getSW();\n            // If the service worker that sent the message is in the list of own\n            // service workers for this instance, dispatch a `message` event.\n            // NOTE: we check for all previously owned service workers rather than\n            // just the current one because some messages (e.g. cache updates) use\n            // a timeout when sent and may be delayed long enough for a service worker\n            // update to be found.\n            if (this._ownSWs.has(source)) {\n                this.dispatchEvent(new WorkboxEvent('message', {\n                    // Can't change type 'any' of data.\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    data,\n                    originalEvent,\n                    ports,\n                    sw: source,\n                }));\n            }\n        };\n        this._scriptURL = scriptURL;\n        this._registerOptions = registerOptions;\n        // Add a message listener immediately since messages received during\n        // page load are buffered only until the DOMContentLoaded event:\n        // https://github.com/GoogleChrome/workbox/issues/2202\n        navigator.serviceWorker.addEventListener('message', this._onMessage);\n    }\n    /**\n     * Registers a service worker for this instances script URL and service\n     * worker options. By default this method delays registration until after\n     * the window has loaded.\n     *\n     * @param {Object} [options]\n     * @param {Function} [options.immediate=false] Setting this to true will\n     *     register the service worker immediately, even if the window has\n     *     not loaded (not recommended).\n     */\n    async register({ immediate = false } = {}) {\n        if (false) {}\n        if (!immediate && document.readyState !== 'complete') {\n            await new Promise((res) => window.addEventListener('load', res));\n        }\n        // Set this flag to true if any service worker was controlling the page\n        // at registration time.\n        this._isUpdate = Boolean(navigator.serviceWorker.controller);\n        // Before registering, attempt to determine if a SW is already controlling\n        // the page, and if that SW script (and version, if specified) matches this\n        // instance's script.\n        this._compatibleControllingSW = this._getControllingSWIfCompatible();\n        this._registration = await this._registerScript();\n        // If we have a compatible controller, store the controller as the \"own\"\n        // SW, resolve active/controlling deferreds and add necessary listeners.\n        if (this._compatibleControllingSW) {\n            this._sw = this._compatibleControllingSW;\n            this._activeDeferred.resolve(this._compatibleControllingSW);\n            this._controllingDeferred.resolve(this._compatibleControllingSW);\n            this._compatibleControllingSW.addEventListener('statechange', this._onStateChange, { once: true });\n        }\n        // If there's a waiting service worker with a matching URL before the\n        // `updatefound` event fires, it likely means that this site is open\n        // in another tab, or the user refreshed the page (and thus the previous\n        // page wasn't fully unloaded before this page started loading).\n        // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n        const waitingSW = this._registration.waiting;\n        if (waitingSW &&\n            urlsMatch(waitingSW.scriptURL, this._scriptURL.toString())) {\n            // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n            // a compatible controller.\n            this._sw = waitingSW;\n            // Run this in the next microtask, so any code that adds an event\n            // listener after awaiting `register()` will get this event.\n            dontWaitFor(Promise.resolve().then(() => {\n                this.dispatchEvent(new WorkboxEvent('waiting', {\n                    sw: waitingSW,\n                    wasWaitingBeforeRegister: true,\n                }));\n                if (false) {}\n            }));\n        }\n        // If an \"own\" SW is already set, resolve the deferred.\n        if (this._sw) {\n            this._swDeferred.resolve(this._sw);\n            this._ownSWs.add(this._sw);\n        }\n        if (false) {}\n        this._registration.addEventListener('updatefound', this._onUpdateFound);\n        navigator.serviceWorker.addEventListener('controllerchange', this._onControllerChange);\n        return this._registration;\n    }\n    /**\n     * Checks for updates of the registered service worker.\n     */\n    async update() {\n        if (!this._registration) {\n            if (false) {}\n            return;\n        }\n        // Try to update registration\n        await this._registration.update();\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is active. If a service worker was already controlling at registration\n     * time then it will resolve to that if the script URLs (and optionally\n     * script versions) match, otherwise it will wait until an update is found\n     * and activates.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get active() {\n        return this._activeDeferred.promise;\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is controlling the page. If a service worker was already controlling at\n     * registration time then it will resolve to that if the script URLs (and\n     * optionally script versions) match, otherwise it will wait until an update\n     * is found and starts controlling the page.\n     * Note: the first time a service worker is installed it will active but\n     * not start controlling the page unless `clients.claim()` is called in the\n     * service worker.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get controlling() {\n        return this._controllingDeferred.promise;\n    }\n    /**\n     * Resolves with a reference to a service worker that matches the script URL\n     * of this instance, as soon as it's available.\n     *\n     * If, at registration time, there's already an active or waiting service\n     * worker with a matching script URL, it will be used (with the waiting\n     * service worker taking precedence over the active service worker if both\n     * match, since the waiting service worker would have been registered more\n     * recently).\n     * If there's no matching active or waiting service worker at registration\n     * time then the promise will not resolve until an update is found and starts\n     * installing, at which point the installing service worker is used.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    getSW() {\n        // If `this._sw` is set, resolve with that as we want `getSW()` to\n        // return the correct (new) service worker if an update is found.\n        return this._sw !== undefined\n            ? Promise.resolve(this._sw)\n            : this._swDeferred.promise;\n    }\n    /**\n     * Sends the passed data object to the service worker registered by this\n     * instance (via {@link workbox-window.Workbox#getSW}) and resolves\n     * with a response (if any).\n     *\n     * A response can be set in a message handler in the service worker by\n     * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n     * returned by `messageSW()`. If no response is set, the promise will never\n     * resolve.\n     *\n     * @param {Object} data An object to send to the service worker\n     * @return {Promise<Object>}\n     */\n    // We might be able to change the 'data' type to Record<string, unknown> in the future.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    async messageSW(data) {\n        const sw = await this.getSW();\n        return messageSW(sw, data);\n    }\n    /**\n     * Sends a `{type: 'SKIP_WAITING'}` message to the service worker that's\n     * currently in the `waiting` state associated with the current registration.\n     *\n     * If there is no current registration or no service worker is `waiting`,\n     * calling this will have no effect.\n     */\n    messageSkipWaiting() {\n        if (this._registration && this._registration.waiting) {\n            void messageSW(this._registration.waiting, SKIP_WAITING_MESSAGE);\n        }\n    }\n    /**\n     * Checks for a service worker already controlling the page and returns\n     * it if its script URL matches.\n     *\n     * @private\n     * @return {ServiceWorker|undefined}\n     */\n    _getControllingSWIfCompatible() {\n        const controller = navigator.serviceWorker.controller;\n        if (controller &&\n            urlsMatch(controller.scriptURL, this._scriptURL.toString())) {\n            return controller;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Registers a service worker for this instances script URL and register\n     * options and tracks the time registration was complete.\n     *\n     * @private\n     */\n    async _registerScript() {\n        try {\n            // this._scriptURL may be a TrustedScriptURL, but there's no support for\n            // passing that to register() in lib.dom right now.\n            // https://github.com/GoogleChrome/workbox/issues/2855\n            const reg = await navigator.serviceWorker.register(this._scriptURL, this._registerOptions);\n            // Keep track of when registration happened, so it can be used in the\n            // `this._onUpdateFound` heuristic. Also use the presence of this\n            // property as a way to see if `.register()` has been called.\n            this._registrationTime = performance.now();\n            return reg;\n        }\n        catch (error) {\n            if (false) {}\n            // Re-throw the error.\n            throw error;\n        }\n    }\n}\n\n// The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n/**\n * The `message` event is dispatched any time a `postMessage` is received.\n *\n * @event workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {MessagePort[]} ports The `ports` value from `originalEvent`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `installed` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * {@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw|registered service worker}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `waiting` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the {@link workbox-window.Workbox#register}\n * method was called.\n *\n * @event workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original\n *    [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event, or `undefined` in the case where the service worker was waiting\n *     to before `.register()` was called.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `activated` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * {@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw|registered service worker}\n * changes to `activated`.\n *\n * @event workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `redundant` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n;// CONCATENATED MODULE: ./node_modules/workbox-window/Workbox.mjs\n\n;// CONCATENATED MODULE: ./node_modules/idb/build/esm/wrap-idb-value.js\nconst instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap_idb_value_wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap_idb_value_wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap_idb_value_wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap_idb_value_wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap_idb_value_wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap_idb_value_wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/idb/build/esm/index.js\n\n\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap_idb_value_wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap_idb_value_wrap(request.result), event.oldVersion, event.newVersion, wrap_idb_value_wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\n\n\n;// CONCATENATED MODULE: ./src/js/database.js\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar dbPromise = openDB('jate', 1, {\n  upgrade: function upgrade(db) {\n    if (!db.objectStoreNames.contains('jate')) {\n      var store = db.createObjectStore('jate', {\n        keyPath: 'id',\n        autoIncrement: true\n      });\n      store.createIndex('content', 'content', {\n        unique: false\n      });\n      console.log('jate database created');\n    }\n  }\n});\n// TODO: Add logic to a method that accepts some content and adds it to the database - complete\nvar putDb = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(content) {\n    var db, tx, store;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return dbPromise;\n        case 2:\n          db = _context.sent;\n          tx = db.transaction('jate', 'readwrite');\n          store = tx.objectStore('jate');\n          _context.next = 7;\n          return store.put({\n            content: content\n          });\n        case 7:\n          _context.next = 9;\n          return tx.complete;\n        case 9:\n          console.log('Content added to the database');\n        case 10:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function putDb(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n// TODO: Add logic for a method that gets all the content from the database - complete\nvar getDb = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var db, tx, store, content;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return dbPromise;\n        case 2:\n          db = _context2.sent;\n          tx = db.transaction('jate', 'readonly');\n          store = tx.objectStore('jate');\n          _context2.next = 7;\n          return store.getAll();\n        case 7:\n          content = _context2.sent;\n          _context2.next = 10;\n          return tx.complete;\n        case 10:\n          return _context2.abrupt(\"return\", content);\n        case 11:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function getDb() {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/* harmony default export */ const database = ((/* unused pure expression or super */ null && (dbPromise)));\n;// CONCATENATED MODULE: ./src/js/header.js\nvar header = \"\\n/*\\n       _____  ____________\\n      / /   |/_  __/ ____/\\n __  / / /| | / / / __/   \\n/ /_/ / ___ |/ / / /___   \\n ____/_/  |_/_/ /_____/   \\njust another text editor\\n*/                          \\n\";\n\n;// CONCATENATED MODULE: ./src/js/editor.js\nfunction editor_typeof(obj) { \"@babel/helpers - typeof\"; return editor_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, editor_typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return editor_typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (editor_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (editor_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n// Import methods to save and get data from the indexedDB database in './database.js'\n\n\nvar _default = /*#__PURE__*/_createClass(function _default() {\n  var _this = this;\n  _classCallCheck(this, _default);\n  var localData = localStorage.getItem('content');\n\n  // check if CodeMirror is loaded\n  if (typeof CodeMirror === 'undefined') {\n    throw new Error('CodeMirror is not loaded');\n  }\n  this.editor = CodeMirror(document.querySelector('#main'), {\n    value: '',\n    mode: 'javascript',\n    theme: 'monokai',\n    lineNumbers: true,\n    lineWrapping: true,\n    autofocus: true,\n    indentUnit: 2,\n    tabSize: 2\n  });\n\n  // When the editor is ready, set the value to whatever is stored in indexeddb.\n  // Fall back to localStorage if nothing is stored in indexeddb, and if neither is available, set the value to header.\n  getDb().then(function (data) {\n    console.info('Loaded data from IndexedDB, injecting into editor');\n    _this.editor.setValue(data || localData || header);\n  });\n  this.editor.on('change', function () {\n    localStorage.setItem('content', _this.editor.getValue());\n  });\n\n  // Save the content of the editor when the editor itself is loses focus\n  this.editor.on('blur', function () {\n    console.log('The editor has lost focus');\n    putDb(localStorage.getItem('content'));\n  });\n});\n\n;// CONCATENATED MODULE: ./src/js/index.js\n\n\n\n\nvar main = document.querySelector('#main');\nmain.innerHTML = '';\nvar loadSpinner = function loadSpinner() {\n  var spinner = document.createElement('div');\n  spinner.classList.add('spinner');\n  spinner.innerHTML = \"\\n  <div class=\\\"loading-container\\\">\\n  <div class=\\\"loading-spinner\\\" />\\n  </div>\\n  \";\n  main.appendChild(spinner);\n};\nvar editor = new _default();\nif (typeof editor === 'undefined') {\n  loadSpinner();\n}\n\n// Check if service workers are supported\nif ('serviceWorker' in navigator) {\n  // register workbox service worker\n  var workboxSW = new Workbox('../../src-sw.js');\n  workboxSW.register('../../src-sw.js');\n} else {\n  console.error('Service workers are not supported in this browser.');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQUk7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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aUJBQWlCLENBQUM7QUFDdkMsQ0FBQyxNQUFNO0VBQ0x4RCxPQUFPLENBQUMvRixLQUFLLENBQUMsb0RBQW9ELENBQUM7QUFDckUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9KQVRFLy4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9EZWZlcnJlZC5qcz9hNDdlIiwid2VicGFjazovL0pBVEUvLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2RvbnRXYWl0Rm9yLmpzPzY5YTUiLCJ3ZWJwYWNrOi8vSkFURS8uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzPzMxOWYiLCJ3ZWJwYWNrOi8vSkFURS8uL25vZGVfbW9kdWxlcy93b3JrYm94LXdpbmRvdy9tZXNzYWdlU1cuanM/N2NiYiIsIndlYnBhY2s6Ly9KQVRFLy4vbm9kZV9tb2R1bGVzL3dvcmtib3gtd2luZG93L3V0aWxzL1dvcmtib3hFdmVudFRhcmdldC5qcz9kYWRiIiwid2VicGFjazovL0pBVEUvLi9ub2RlX21vZHVsZXMvd29ya2JveC13aW5kb3cvdXRpbHMvdXJsc01hdGNoLmpzPzFkZTQiLCJ3ZWJwYWNrOi8vSkFURS8uL25vZGVfbW9kdWxlcy93b3JrYm94LXdpbmRvdy91dGlscy9Xb3JrYm94RXZlbnQuanM/Yjg2OCIsIndlYnBhY2s6Ly9KQVRFLy4vbm9kZV9tb2R1bGVzL3dvcmtib3gtd2luZG93L1dvcmtib3guanM/M2RlZSIsIndlYnBhY2s6Ly9KQVRFLy4vbm9kZV9tb2R1bGVzL3dvcmtib3gtd2luZG93L1dvcmtib3gubWpzP2IxODQiLCJ3ZWJwYWNrOi8vSkFURS8uL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvZXNtL3dyYXAtaWRiLXZhbHVlLmpzPzc5ZDIiLCJ3ZWJwYWNrOi8vSkFURS8uL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvZXNtL2luZGV4LmpzPzNmNGYiLCJ3ZWJwYWNrOi8vSkFURS8uL3NyYy9qcy9kYXRhYmFzZS5qcz8zZmEyIiwid2VicGFjazovL0pBVEUvLi9zcmMvanMvaGVhZGVyLmpzP2NhNzUiLCJ3ZWJwYWNrOi8vSkFURS8uL3NyYy9qcy9lZGl0b3IuanM/NjZmNSIsIndlYnBhY2s6Ly9KQVRFLy4vc3JjL2pzL2luZGV4LmpzPzdiYTUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFRoZSBEZWZlcnJlZCBjbGFzcyBjb21wb3NlcyBQcm9taXNlcyBpbiBhIHdheSB0aGF0IGFsbG93cyBmb3IgdGhlbSB0byBiZVxuICogcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgZnJvbSBvdXRzaWRlIHRoZSBjb25zdHJ1Y3Rvci4gSW4gbW9zdCBjYXNlcyBwcm9taXNlc1xuICogc2hvdWxkIGJlIHVzZWQgZGlyZWN0bHksIGJ1dCBEZWZlcnJlZHMgY2FuIGJlIG5lY2Vzc2FyeSB3aGVuIHRoZSBsb2dpYyB0b1xuICogcmVzb2x2ZSBhIHByb21pc2UgbXVzdCBiZSBzZXBhcmF0ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHByb21pc2UgYW5kIGV4cG9zZXMgaXRzIHJlc29sdmUgYW5kIHJlamVjdCBmdW5jdGlvbnMgYXMgbWV0aG9kcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgeyBEZWZlcnJlZCB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHByZXZlbnRzIGEgcHJvbWlzZSBmcm9tIGJlaW5nIGZsYWdnZWQgYXMgdW51c2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZG9udFdhaXRGb3IocHJvbWlzZSkge1xuICAgIC8vIEVmZmVjdGl2ZSBuby1vcC5cbiAgICB2b2lkIHByb21pc2UudGhlbigoKSA9PiB7IH0pO1xufVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuY29uc3QgbG9nZ2VyID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbidcbiAgICA/IG51bGxcbiAgICA6ICgoKSA9PiB7XG4gICAgICAgIC8vIERvbid0IG92ZXJ3cml0ZSB0aGlzIHZhbHVlIGlmIGl0J3MgYWxyZWFkeSBzZXQuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvcHVsbC8yMjg0I2lzc3VlY29tbWVudC01NjA0NzA5MjNcbiAgICAgICAgaWYgKCEoJ19fV0JfRElTQUJMRV9ERVZfTE9HUycgaW4gZ2xvYmFsVGhpcykpIHtcbiAgICAgICAgICAgIHNlbGYuX19XQl9ESVNBQkxFX0RFVl9MT0dTID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbWV0aG9kVG9Db2xvck1hcCA9IHtcbiAgICAgICAgICAgIGRlYnVnOiBgIzdmOGM4ZGAsXG4gICAgICAgICAgICBsb2c6IGAjMmVjYzcxYCxcbiAgICAgICAgICAgIHdhcm46IGAjZjM5YzEyYCxcbiAgICAgICAgICAgIGVycm9yOiBgI2MwMzkyYmAsXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogYCMzNDk4ZGJgLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IG51bGwsIC8vIE5vIGNvbG9yZWQgcHJlZml4IG9uIGdyb3VwRW5kXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByaW50ID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJncykge1xuICAgICAgICAgICAgaWYgKHNlbGYuX19XQl9ESVNBQkxFX0RFVl9MT0dTKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2dyb3VwQ29sbGFwc2VkJykge1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IHByaW50IGFsbCBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKCkgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODI3NTRcbiAgICAgICAgICAgICAgICBpZiAoL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlW21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHlsZXMgPSBbXG4gICAgICAgICAgICAgICAgYGJhY2tncm91bmQ6ICR7bWV0aG9kVG9Db2xvck1hcFttZXRob2RdfWAsXG4gICAgICAgICAgICAgICAgYGJvcmRlci1yYWRpdXM6IDAuNWVtYCxcbiAgICAgICAgICAgICAgICBgY29sb3I6IHdoaXRlYCxcbiAgICAgICAgICAgICAgICBgZm9udC13ZWlnaHQ6IGJvbGRgLFxuICAgICAgICAgICAgICAgIGBwYWRkaW5nOiAycHggMC41ZW1gLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIFdoZW4gaW4gYSBncm91cCwgdGhlIHdvcmtib3ggcHJlZml4IGlzIG5vdCBkaXNwbGF5ZWQuXG4gICAgICAgICAgICBjb25zdCBsb2dQcmVmaXggPSBpbkdyb3VwID8gW10gOiBbJyVjd29ya2JveCcsIHN0eWxlcy5qb2luKCc7JyldO1xuICAgICAgICAgICAgY29uc29sZVttZXRob2RdKC4uLmxvZ1ByZWZpeCwgLi4uYXJncyk7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSAnZ3JvdXBDb2xsYXBzZWQnKSB7XG4gICAgICAgICAgICAgICAgaW5Hcm91cCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSAnZ3JvdXBFbmQnKSB7XG4gICAgICAgICAgICAgICAgaW5Hcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgICAgICBjb25zdCBhcGkgPSB7fTtcbiAgICAgICAgY29uc3QgbG9nZ2VyTWV0aG9kcyA9IE9iamVjdC5rZXlzKG1ldGhvZFRvQ29sb3JNYXApO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBsb2dnZXJNZXRob2RzKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSBrZXk7XG4gICAgICAgICAgICBhcGlbbWV0aG9kXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJpbnQobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9KSgpKTtcbmV4cG9ydCB7IGxvZ2dlciB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogU2VuZHMgYSBkYXRhIG9iamVjdCB0byBhIHNlcnZpY2Ugd29ya2VyIHZpYSBgcG9zdE1lc3NhZ2VgIGFuZCByZXNvbHZlcyB3aXRoXG4gKiBhIHJlc3BvbnNlIChpZiBhbnkpLlxuICpcbiAqIEEgcmVzcG9uc2UgY2FuIGJlIHNldCBpbiBhIG1lc3NhZ2UgaGFuZGxlciBpbiB0aGUgc2VydmljZSB3b3JrZXIgYnlcbiAqIGNhbGxpbmcgYGV2ZW50LnBvcnRzWzBdLnBvc3RNZXNzYWdlKC4uLilgLCB3aGljaCB3aWxsIHJlc29sdmUgdGhlIHByb21pc2VcbiAqIHJldHVybmVkIGJ5IGBtZXNzYWdlU1coKWAuIElmIG5vIHJlc3BvbnNlIGlzIHNldCwgdGhlIHByb21pc2Ugd2lsbCBub3RcbiAqIHJlc29sdmUuXG4gKlxuICogQHBhcmFtIHtTZXJ2aWNlV29ya2VyfSBzdyBUaGUgc2VydmljZSB3b3JrZXIgdG8gc2VuZCB0aGUgbWVzc2FnZSB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCB0byBzZW5kIHRvIHRoZSBzZXJ2aWNlIHdvcmtlci5cbiAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0fHVuZGVmaW5lZD59XG4gKiBAbWVtYmVyb2Ygd29ya2JveC13aW5kb3dcbiAqL1xuLy8gQmV0dGVyIG5vdCBjaGFuZ2UgdHlwZSBvZiBkYXRhLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmZ1bmN0aW9uIG1lc3NhZ2VTVyhzdywgZGF0YSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlQ2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoZXZlbnQuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHN3LnBvc3RNZXNzYWdlKGRhdGEsIFttZXNzYWdlQ2hhbm5lbC5wb3J0Ml0pO1xuICAgIH0pO1xufVxuZXhwb3J0IHsgbWVzc2FnZVNXIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG4vKipcbiAqIEEgbWluaW1hbCBgRXZlbnRUYXJnZXRgIHNoaW0uXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjb25zdHJ1Y3RhYmxlXG4gKiBgRXZlbnRUYXJnZXRgLCBzbyB1c2luZyBhIHJlYWwgYEV2ZW50VGFyZ2V0YCB3aWxsIGVycm9yLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFdvcmtib3hFdmVudFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJSZWdpc3RyeSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBmb28gPSB0aGlzLl9nZXRFdmVudExpc3RlbmVyc0J5VHlwZSh0eXBlKTtcbiAgICAgICAgZm9vLmFkZChsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fZ2V0RXZlbnRMaXN0ZW5lcnNCeVR5cGUodHlwZSkuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2dldEV2ZW50TGlzdGVuZXJzQnlUeXBlKGV2ZW50LnR5cGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBTZXQgb2YgbGlzdGVuZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGFzc2VkIGV2ZW50IHR5cGUuXG4gICAgICogSWYgbm8gaGFuZGxlcnMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQsIGFuIGVtcHR5IFNldCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEByZXR1cm4ge1NldDxMaXN0ZW5lckNhbGxiYWNrPn0gQW4gYXJyYXkgb2YgaGFuZGxlciBmdW5jdGlvbnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0RXZlbnRMaXN0ZW5lcnNCeVR5cGUodHlwZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50TGlzdGVuZXJSZWdpc3RyeS5oYXModHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJSZWdpc3RyeS5zZXQodHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRMaXN0ZW5lclJlZ2lzdHJ5LmdldCh0eXBlKTtcbiAgICB9XG59XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHR3byBVUkxzIGhhdmUgdGhlIHNhbWUgYC5ocmVmYCBwcm9wZXJ0eS4gVGhlIFVSTFMgY2FuIGJlXG4gKiByZWxhdGl2ZSwgYW5kIGlmIHRoZXkgYXJlIHRoZSBjdXJyZW50IGxvY2F0aW9uIGhyZWYgaXMgdXNlZCB0byByZXNvbHZlIFVSTHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwxXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsMlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVybHNNYXRjaCh1cmwxLCB1cmwyKSB7XG4gICAgY29uc3QgeyBocmVmIH0gPSBsb2NhdGlvbjtcbiAgICByZXR1cm4gbmV3IFVSTCh1cmwxLCBocmVmKS5ocmVmID09PSBuZXcgVVJMKHVybDIsIGhyZWYpLmhyZWY7XG59XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogQSBtaW5pbWFsIGBFdmVudGAgc3ViY2xhc3Mgc2hpbS5cbiAqIFRoaXMgZG9lc24ndCAqYWN0dWFsbHkqIHN1YmNsYXNzIGBFdmVudGAgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnRcbiAqIGNvbnN0cnVjdGFibGUgYEV2ZW50VGFyZ2V0YCwgYW5kIHVzaW5nIGEgcmVhbCBgRXZlbnRgIHdpbGwgZXJyb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgV29ya2JveEV2ZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICB9XG59XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9EZWZlcnJlZC5qcyc7XG5pbXBvcnQgeyBkb250V2FpdEZvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9kb250V2FpdEZvci5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IG1lc3NhZ2VTVyB9IGZyb20gJy4vbWVzc2FnZVNXLmpzJztcbmltcG9ydCB7IFdvcmtib3hFdmVudFRhcmdldCB9IGZyb20gJy4vdXRpbHMvV29ya2JveEV2ZW50VGFyZ2V0LmpzJztcbmltcG9ydCB7IHVybHNNYXRjaCB9IGZyb20gJy4vdXRpbHMvdXJsc01hdGNoLmpzJztcbmltcG9ydCB7IFdvcmtib3hFdmVudCB9IGZyb20gJy4vdXRpbHMvV29ya2JveEV2ZW50LmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vLyBUaGUgdGltZSBhIFNXIG11c3QgYmUgaW4gdGhlIHdhaXRpbmcgcGhhc2UgYmVmb3JlIHdlIGNhbiBjb25jbHVkZVxuLy8gYHNraXBXYWl0aW5nKClgIHdhc24ndCBjYWxsZWQuIFRoaXMgMjAwIGFtb3VudCB3YXNuJ3Qgc2NpZW50aWZpY2FsbHlcbi8vIGNob3NlbiwgYnV0IGl0IHNlZW1zIHRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcyBpbiBteSB0ZXN0aW5nLlxuY29uc3QgV0FJVElOR19USU1FT1VUX0RVUkFUSU9OID0gMjAwO1xuLy8gVGhlIGFtb3VudCBvZiB0aW1lIGFmdGVyIGEgcmVnaXN0cmF0aW9uIHRoYXQgd2UgY2FuIHJlYXNvbmFibHkgY29uY2x1ZGVcbi8vIHRoYXQgdGhlIHJlZ2lzdHJhdGlvbiBkaWRuJ3QgdHJpZ2dlciBhbiB1cGRhdGUuXG5jb25zdCBSRUdJU1RSQVRJT05fVElNRU9VVF9EVVJBVElPTiA9IDYwMDAwO1xuLy8gVGhlIGRlIGZhY3RvIHN0YW5kYXJkIG1lc3NhZ2UgdGhhdCBhIHNlcnZpY2Ugd29ya2VyIHNob3VsZCBiZSBsaXN0ZW5pbmcgZm9yXG4vLyB0byB0cmlnZ2VyIGEgY2FsbCB0byBza2lwV2FpdGluZygpLlxuY29uc3QgU0tJUF9XQUlUSU5HX01FU1NBR0UgPSB7IHR5cGU6ICdTS0lQX1dBSVRJTkcnIH07XG4vKipcbiAqIEEgY2xhc3MgdG8gYWlkIGluIGhhbmRsaW5nIHNlcnZpY2Ugd29ya2VyIHJlZ2lzdHJhdGlvbiwgdXBkYXRlcywgYW5kXG4gKiByZWFjdGluZyB0byBzZXJ2aWNlIHdvcmtlciBsaWZlY3ljbGUgZXZlbnRzLlxuICpcbiAqIEBmaXJlcyB7QGxpbmsgd29ya2JveC13aW5kb3cuV29ya2JveCNtZXNzYWdlfVxuICogQGZpcmVzIHtAbGluayB3b3JrYm94LXdpbmRvdy5Xb3JrYm94I2luc3RhbGxlZH1cbiAqIEBmaXJlcyB7QGxpbmsgd29ya2JveC13aW5kb3cuV29ya2JveCN3YWl0aW5nfVxuICogQGZpcmVzIHtAbGluayB3b3JrYm94LXdpbmRvdy5Xb3JrYm94I2NvbnRyb2xsaW5nfVxuICogQGZpcmVzIHtAbGluayB3b3JrYm94LXdpbmRvdy5Xb3JrYm94I2FjdGl2YXRlZH1cbiAqIEBmaXJlcyB7QGxpbmsgd29ya2JveC13aW5kb3cuV29ya2JveCNyZWR1bmRhbnR9XG4gKiBAbWVtYmVyb2Ygd29ya2JveC13aW5kb3dcbiAqL1xuY2xhc3MgV29ya2JveCBleHRlbmRzIFdvcmtib3hFdmVudFRhcmdldCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBXb3JrYm94IGluc3RhbmNlIHdpdGggYSBzY3JpcHQgVVJMIGFuZCBzZXJ2aWNlIHdvcmtlclxuICAgICAqIG9wdGlvbnMuIFRoZSBzY3JpcHQgVVJMIGFuZCBvcHRpb25zIGFyZSB0aGUgc2FtZSBhcyB0aG9zZSB1c2VkIHdoZW5cbiAgICAgKiBjYWxsaW5nIFtuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3RlcihzY3JpcHRVUkwsIG9wdGlvbnMpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmljZVdvcmtlckNvbnRhaW5lci9yZWdpc3RlcikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xUcnVzdGVkU2NyaXB0VVJMfSBzY3JpcHRVUkwgVGhlIHNlcnZpY2Ugd29ya2VyIHNjcmlwdFxuICAgICAqICAgICBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZS4gVXNpbmcgYVxuICAgICAqICAgICBbYFRydXN0ZWRTY3JpcHRVUkxgXShodHRwczovL3dlYi5kZXYvdHJ1c3RlZC10eXBlcy8pIGlzIHN1cHBvcnRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3JlZ2lzdGVyT3B0aW9uc10gVGhlIHNlcnZpY2Ugd29ya2VyIG9wdGlvbnMgYXNzb2NpYXRlZFxuICAgICAqICAgICB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgICBjb25zdHJ1Y3RvcihzY3JpcHRVUkwsIHJlZ2lzdGVyT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyT3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLl91cGRhdGVGb3VuZENvdW50ID0gMDtcbiAgICAgICAgLy8gRGVmZXJyZWRzIHdlIGNhbiByZXNvbHZlIGxhdGVyLlxuICAgICAgICB0aGlzLl9zd0RlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZURlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xsaW5nRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0cmF0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMuX293blNXcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vblVwZGF0ZUZvdW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gYHRoaXMuX3JlZ2lzdHJhdGlvbmAgd2lsbCBuZXZlciBiZSBgdW5kZWZpbmVkYCBhZnRlciBhbiB1cGRhdGUgaXMgZm91bmQuXG4gICAgICAgICAgICBjb25zdCByZWdpc3RyYXRpb24gPSB0aGlzLl9yZWdpc3RyYXRpb247XG4gICAgICAgICAgICBjb25zdCBpbnN0YWxsaW5nU1cgPSByZWdpc3RyYXRpb24uaW5zdGFsbGluZztcbiAgICAgICAgICAgIC8vIElmIHRoZSBzY3JpcHQgVVJMIHBhc3NlZCB0byBgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIoKWAgaXNcbiAgICAgICAgICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IGNvbnRyb2xsaW5nIFNXJ3Mgc2NyaXB0IFVSTCwgd2Uga25vdyBhbnlcbiAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgcmVnaXN0cmF0aW9uIGNhbGxzIHdpbGwgdHJpZ2dlciBhbiBgdXBkYXRlZm91bmRgIGV2ZW50LlxuICAgICAgICAgICAgLy8gQnV0IGlmIHRoZSByZWdpc3RlcmVkIHNjcmlwdCBVUkwgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgY29udHJvbGxpbmdcbiAgICAgICAgICAgIC8vIFNXJ3Mgc2NyaXB0IFVSTCwgd2UnbGwgb25seSBnZXQgYW4gYHVwZGF0ZWZvdW5kYCBldmVudCBpZiB0aGUgZmlsZVxuICAgICAgICAgICAgLy8gY2hhbmdlZCBzaW5jZSBpdCB3YXMgbGFzdCByZWdpc3RlcmVkLiBUaGlzIGNhbiBiZSBhIHByb2JsZW0gaWYgdGhlIHVzZXJcbiAgICAgICAgICAgIC8vIG9wZW5zIHVwIHRoZSBzYW1lIHBhZ2UgaW4gYSBkaWZmZXJlbnQgdGFiLCBhbmQgdGhhdCBwYWdlIHJlZ2lzdGVyc1xuICAgICAgICAgICAgLy8gYSBTVyB0aGF0IHRyaWdnZXJzIGFuIHVwZGF0ZS4gSXQncyBhIHByb2JsZW0gYmVjYXVzZSB0aGlzIHBhZ2UgaGFzIG5vXG4gICAgICAgICAgICAvLyBnb29kIHdheSBvZiBrbm93aW5nIHdoZXRoZXIgdGhlIGB1cGRhdGVmb3VuZGAgZXZlbnQgY2FtZSBmcm9tIHRoZSBTV1xuICAgICAgICAgICAgLy8gc2NyaXB0IGl0IHJlZ2lzdGVyZWQgb3IgZnJvbSBhIHJlZ2lzdHJhdGlvbiBhdHRlbXB0IG1hZGUgYnkgYSBuZXdlclxuICAgICAgICAgICAgLy8gdmVyc2lvbiBvZiB0aGUgcGFnZSBydW5uaW5nIGluIGFub3RoZXIgdGFiLlxuICAgICAgICAgICAgLy8gVG8gbWluaW1pemUgdGhlIHBvc3NpYmlsaXR5IG9mIGEgZmFsc2UgcG9zaXRpdmUsIHdlIHVzZSB0aGUgbG9naWMgaGVyZTpcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUxpa2VseVRyaWdnZXJlZEV4dGVybmFsbHkgPSBcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGVuZm9yY2Ugb25seSBjYWxsaW5nIGByZWdpc3RlcigpYCBvbmNlLCBhbmQgc2luY2Ugd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgYHVwZGF0ZWZvdW5kYCBldmVudCBsaXN0ZW5lciB1bnRpbCB0aGUgYHJlZ2lzdGVyKClgIGNhbGwsIGlmXG4gICAgICAgICAgICAvLyBgX3VwZGF0ZUZvdW5kQ291bnRgIGlzID4gMCB0aGVuIGl0IG1lYW5zIHRoaXMgbWV0aG9kIGhhcyBhbHJlYWR5XG4gICAgICAgICAgICAvLyBiZWVuIGNhbGxlZCwgdGh1cyB0aGlzIFNXIG11c3QgYmUgZXh0ZXJuYWxcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZvdW5kQ291bnQgPiAwIHx8XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNjcmlwdCBVUkwgb2YgdGhlIGluc3RhbGxpbmcgU1cgaXMgZGlmZmVyZW50IGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlJ3Mgc2NyaXB0IFVSTCwgd2Uga25vdyBpdCdzIGRlZmluaXRlbHkgbm90IGZyb20gb3VyXG4gICAgICAgICAgICAgICAgLy8gcmVnaXN0cmF0aW9uLlxuICAgICAgICAgICAgICAgICF1cmxzTWF0Y2goaW5zdGFsbGluZ1NXLnNjcmlwdFVSTCwgdGhpcy5fc2NyaXB0VVJMLnRvU3RyaW5nKCkpIHx8XG4gICAgICAgICAgICAgICAgLy8gSWYgYWxsIG9mIHRoZSBhYm92ZSBhcmUgZmFsc2UsIHRoZW4gd2UgdXNlIGEgdGltZS1iYXNlZCBoZXVyaXN0aWM6XG4gICAgICAgICAgICAgICAgLy8gQW55IGB1cGRhdGVmb3VuZGAgZXZlbnQgdGhhdCBvY2N1cnMgbG9uZyBhZnRlciBvdXIgcmVnaXN0cmF0aW9uIGlzXG4gICAgICAgICAgICAgICAgLy8gYXNzdW1lZCB0byBiZSBleHRlcm5hbC5cbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5ub3coKSA+IHRoaXMuX3JlZ2lzdHJhdGlvblRpbWUgKyBSRUdJU1RSQVRJT05fVElNRU9VVF9EVVJBVElPTlxuICAgICAgICAgICAgICAgID8gLy8gSWYgYW55IG9mIHRoZSBhYm92ZSBhcmUgbm90IHRydWUsIHdlIGFzc3VtZSB0aGUgdXBkYXRlIHdhc1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyZWQgYnkgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICBpZiAodXBkYXRlTGlrZWx5VHJpZ2dlcmVkRXh0ZXJuYWxseSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4dGVybmFsU1cgPSBpbnN0YWxsaW5nU1c7XG4gICAgICAgICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWZvdW5kJywgdGhpcy5fb25VcGRhdGVGb3VuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXBkYXRlIHdhcyBub3QgdHJpZ2dlcmVkIGV4dGVybmFsbHkgd2Uga25vdyB0aGUgaW5zdGFsbGluZ1xuICAgICAgICAgICAgICAgIC8vIFNXIGlzIHRoZSBvbmUgd2UgcmVnaXN0ZXJlZCwgc28gd2Ugc2V0IGl0LlxuICAgICAgICAgICAgICAgIHRoaXMuX3N3ID0gaW5zdGFsbGluZ1NXO1xuICAgICAgICAgICAgICAgIHRoaXMuX293blNXcy5hZGQoaW5zdGFsbGluZ1NXKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zd0RlZmVycmVkLnJlc29sdmUoaW5zdGFsbGluZ1NXKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYGluc3RhbGxpbmdgIHN0YXRlIGlzbid0IHNvbWV0aGluZyB3ZSBoYXZlIGEgZGVkaWNhdGVkXG4gICAgICAgICAgICAgICAgLy8gY2FsbGJhY2sgZm9yLCBidXQgd2UgZG8gbG9nIG1lc3NhZ2VzIGZvciBpdCBpbiBkZXZlbG9wbWVudC5cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnVXBkYXRlZCBzZXJ2aWNlIHdvcmtlciBmb3VuZC4gSW5zdGFsbGluZyBub3cuLi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1NlcnZpY2Ugd29ya2VyIGlzIGluc3RhbGxpbmcuLi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluY3JlbWVudCB0aGUgYHVwZGF0ZWZvdW5kYCBjb3VudCwgc28gZnV0dXJlIGludm9jYXRpb25zIG9mIHRoaXNcbiAgICAgICAgICAgIC8vIG1ldGhvZCBjYW4gYmUgc3VyZSB0aGV5IHdlcmUgdHJpZ2dlcmVkIGV4dGVybmFsbHkuXG4gICAgICAgICAgICArK3RoaXMuX3VwZGF0ZUZvdW5kQ291bnQ7XG4gICAgICAgICAgICAvLyBBZGQgYSBgc3RhdGVjaGFuZ2VgIGxpc3RlbmVyIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHVwZGF0ZSB3YXNcbiAgICAgICAgICAgIC8vIHRyaWdnZXJlZCBleHRlcm5hbGx5LCBzaW5jZSB3ZSBoYXZlIGNhbGxiYWNrcyBmb3IgYm90aC5cbiAgICAgICAgICAgIGluc3RhbGxpbmdTVy5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIHRoaXMuX29uU3RhdGVDaGFuZ2UpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gb3JpZ2luYWxFdmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25TdGF0ZUNoYW5nZSA9IChvcmlnaW5hbEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBgdGhpcy5fcmVnaXN0cmF0aW9uYCB3aWxsIG5ldmVyIGJlIGB1bmRlZmluZWRgIGFmdGVyIGFuIHVwZGF0ZSBpcyBmb3VuZC5cbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IHRoaXMuX3JlZ2lzdHJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHN3ID0gb3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBzdztcbiAgICAgICAgICAgIGNvbnN0IGlzRXh0ZXJuYWwgPSBzdyA9PT0gdGhpcy5fZXh0ZXJuYWxTVztcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50UHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgc3csXG4gICAgICAgICAgICAgICAgaXNFeHRlcm5hbCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghaXNFeHRlcm5hbCAmJiB0aGlzLl9pc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50UHJvcHMuaXNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBXb3JrYm94RXZlbnQoc3RhdGUsIGV2ZW50UHJvcHMpKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2luc3RhbGxlZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHRpbWVvdXQgaXMgdXNlZCB0byBpZ25vcmUgY2FzZXMgd2hlcmUgdGhlIHNlcnZpY2Ugd29ya2VyIGNhbGxzXG4gICAgICAgICAgICAgICAgLy8gYHNraXBXYWl0aW5nKClgIGluIHRoZSBpbnN0YWxsIGV2ZW50LCB0aHVzIG1vdmluZyBpdCBkaXJlY3RseSBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0aW5nIHN0YXRlLiAoU2luY2UgYWxsIHNlcnZpY2Ugd29ya2VycyAqbXVzdCogZ28gdGhyb3VnaCB0aGVcbiAgICAgICAgICAgICAgICAvLyB3YWl0aW5nIHBoYXNlLCB0aGUgb25seSB3YXkgdG8gZGV0ZWN0IGBza2lwV2FpdGluZygpYCBjYWxsZWQgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFsbCBldmVudCBpcyB0byBvYnNlcnZlIHRoYXQgdGhlIHRpbWUgc3BlbnQgaW4gdGhlIHdhaXRpbmcgcGhhc2VcbiAgICAgICAgICAgICAgICAvLyBpcyB2ZXJ5IHNob3J0LilcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBkb24ndCBuZWVkIHNlcGFyYXRlIHRpbWVvdXRzIGZvciB0aGUgb3duIGFuZCBleHRlcm5hbCBTV3NcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGNhbid0IGdvIHRocm91Z2ggdGhlc2UgcGhhc2VzIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAgICAgdGhpcy5fd2FpdGluZ1RpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIFNXIGlzIHN0aWxsIHdhaXRpbmcgKGl0IG1heSBub3cgYmUgcmVkdW5kYW50KS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnaW5zdGFsbGVkJyAmJiByZWdpc3RyYXRpb24ud2FpdGluZyA9PT0gc3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgV29ya2JveEV2ZW50KCd3YWl0aW5nJywgZXZlbnRQcm9wcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybignQW4gZXh0ZXJuYWwgc2VydmljZSB3b3JrZXIgaGFzIGluc3RhbGxlZCBidXQgaXMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd2FpdGluZyBmb3IgdGhpcyBjbGllbnQgdG8gY2xvc2UgYmVmb3JlIGFjdGl2YXRpbmcuLi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdUaGUgc2VydmljZSB3b3JrZXIgaGFzIGluc3RhbGxlZCBidXQgaXMgd2FpdGluZyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmb3IgZXhpc3RpbmcgY2xpZW50cyB0byBjbG9zZSBiZWZvcmUgYWN0aXZhdGluZy4uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFdBSVRJTkdfVElNRU9VVF9EVVJBVElPTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2FjdGl2YXRpbmcnKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3dhaXRpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGVmZXJyZWQucmVzb2x2ZShzdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luc3RhbGxlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdBbiBleHRlcm5hbCBzZXJ2aWNlIHdvcmtlciBoYXMgaW5zdGFsbGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1lvdSBtYXkgd2FudCB0byBzdWdnZXN0IHVzZXJzIHJlbG9hZCB0aGlzIHBhZ2UuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdSZWdpc3RlcmVkIHNlcnZpY2Ugd29ya2VyIGluc3RhbGxlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhY3RpdmF0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybignQW4gZXh0ZXJuYWwgc2VydmljZSB3b3JrZXIgaGFzIGFjdGl2YXRlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1JlZ2lzdGVyZWQgc2VydmljZSB3b3JrZXIgYWN0aXZhdGVkLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdyAhPT0gbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybignVGhlIHJlZ2lzdGVyZWQgc2VydmljZSB3b3JrZXIgaXMgYWN0aXZlIGJ1dCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdub3QgeWV0IGNvbnRyb2xsaW5nIHRoZSBwYWdlLiBSZWxvYWQgb3IgcnVuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2BjbGllbnRzLmNsYWltKClgIGluIHRoZSBzZXJ2aWNlIHdvcmtlci4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVkdW5kYW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdyA9PT0gdGhpcy5fY29tcGF0aWJsZUNvbnRyb2xsaW5nU1cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdQcmV2aW91c2x5IGNvbnRyb2xsaW5nIHNlcnZpY2Ugd29ya2VyIG5vdyByZWR1bmRhbnQhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1JlZ2lzdGVyZWQgc2VydmljZSB3b3JrZXIgbm93IHJlZHVuZGFudCEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IG9yaWdpbmFsRXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uQ29udHJvbGxlckNoYW5nZSA9IChvcmlnaW5hbEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdyA9IHRoaXMuX3N3O1xuICAgICAgICAgICAgY29uc3QgaXNFeHRlcm5hbCA9IHN3ICE9PSBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyO1xuICAgICAgICAgICAgLy8gVW5jb25kaXRpb25hbGx5IGRpc3BhdGNoIHRoZSBjb250cm9sbGluZyBldmVudCwgd2l0aCBpc0V4dGVybmFsIHNldFxuICAgICAgICAgICAgLy8gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBjb250cm9sbGVyIGNoYW5nZXMgZHVlIHRvIHRoZSBpbml0aWFsIHJlZ2lzdHJhdGlvblxuICAgICAgICAgICAgLy8gdnMuIGFuIHVwZGF0ZS1jaGVjayBvciBvdGhlciB0YWIncyByZWdpc3RyYXRpb24uXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8yNzg2XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFdvcmtib3hFdmVudCgnY29udHJvbGxpbmcnLCB7XG4gICAgICAgICAgICAgICAgaXNFeHRlcm5hbCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgICAgIHN3LFxuICAgICAgICAgICAgICAgIGlzVXBkYXRlOiB0aGlzLl9pc1VwZGF0ZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmICghaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1JlZ2lzdGVyZWQgc2VydmljZSB3b3JrZXIgbm93IGNvbnRyb2xsaW5nIHRoaXMgcGFnZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udHJvbGxpbmdEZWZlcnJlZC5yZXNvbHZlKHN3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IG9yaWdpbmFsRXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uTWVzc2FnZSA9IGFzeW5jIChvcmlnaW5hbEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBDYW4ndCBjaGFuZ2UgdHlwZSAnYW55JyBvZiBkYXRhLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBwb3J0cywgc291cmNlIH0gPSBvcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCB0aGVyZSdzIGFuIFwib3duXCIgc2VydmljZSB3b3JrZXIuIFRoaXMgaXMgdXNlZCB0byBidWZmZXJcbiAgICAgICAgICAgIC8vIGBtZXNzYWdlYCBldmVudHMgdGhhdCBtYXkgYmUgcmVjZWl2ZWQgcHJpb3IgdG8gY2FsbGluZyBgcmVnaXN0ZXIoKWAuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmdldFNXKCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VydmljZSB3b3JrZXIgdGhhdCBzZW50IHRoZSBtZXNzYWdlIGlzIGluIHRoZSBsaXN0IG9mIG93blxuICAgICAgICAgICAgLy8gc2VydmljZSB3b3JrZXJzIGZvciB0aGlzIGluc3RhbmNlLCBkaXNwYXRjaCBhIGBtZXNzYWdlYCBldmVudC5cbiAgICAgICAgICAgIC8vIE5PVEU6IHdlIGNoZWNrIGZvciBhbGwgcHJldmlvdXNseSBvd25lZCBzZXJ2aWNlIHdvcmtlcnMgcmF0aGVyIHRoYW5cbiAgICAgICAgICAgIC8vIGp1c3QgdGhlIGN1cnJlbnQgb25lIGJlY2F1c2Ugc29tZSBtZXNzYWdlcyAoZS5nLiBjYWNoZSB1cGRhdGVzKSB1c2VcbiAgICAgICAgICAgIC8vIGEgdGltZW91dCB3aGVuIHNlbnQgYW5kIG1heSBiZSBkZWxheWVkIGxvbmcgZW5vdWdoIGZvciBhIHNlcnZpY2Ugd29ya2VyXG4gICAgICAgICAgICAvLyB1cGRhdGUgdG8gYmUgZm91bmQuXG4gICAgICAgICAgICBpZiAodGhpcy5fb3duU1dzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBXb3JrYm94RXZlbnQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbid0IGNoYW5nZSB0eXBlICdhbnknIG9mIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgcG9ydHMsXG4gICAgICAgICAgICAgICAgICAgIHN3OiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zY3JpcHRVUkwgPSBzY3JpcHRVUkw7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyT3B0aW9ucyA9IHJlZ2lzdGVyT3B0aW9ucztcbiAgICAgICAgLy8gQWRkIGEgbWVzc2FnZSBsaXN0ZW5lciBpbW1lZGlhdGVseSBzaW5jZSBtZXNzYWdlcyByZWNlaXZlZCBkdXJpbmdcbiAgICAgICAgLy8gcGFnZSBsb2FkIGFyZSBidWZmZXJlZCBvbmx5IHVudGlsIHRoZSBET01Db250ZW50TG9hZGVkIGV2ZW50OlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvaXNzdWVzLzIyMDJcbiAgICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX29uTWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHNlcnZpY2Ugd29ya2VyIGZvciB0aGlzIGluc3RhbmNlcyBzY3JpcHQgVVJMIGFuZCBzZXJ2aWNlXG4gICAgICogd29ya2VyIG9wdGlvbnMuIEJ5IGRlZmF1bHQgdGhpcyBtZXRob2QgZGVsYXlzIHJlZ2lzdHJhdGlvbiB1bnRpbCBhZnRlclxuICAgICAqIHRoZSB3aW5kb3cgaGFzIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5pbW1lZGlhdGU9ZmFsc2VdIFNldHRpbmcgdGhpcyB0byB0cnVlIHdpbGxcbiAgICAgKiAgICAgcmVnaXN0ZXIgdGhlIHNlcnZpY2Ugd29ya2VyIGltbWVkaWF0ZWx5LCBldmVuIGlmIHRoZSB3aW5kb3cgaGFzXG4gICAgICogICAgIG5vdCBsb2FkZWQgKG5vdCByZWNvbW1lbmRlZCkuXG4gICAgICovXG4gICAgYXN5bmMgcmVnaXN0ZXIoeyBpbW1lZGlhdGUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWdpc3RyYXRpb25UaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3QgcmUtcmVnaXN0ZXIgYSBXb3JrYm94IGluc3RhbmNlIGFmdGVyIGl0IGhhcyAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2JlZW4gcmVnaXN0ZXJlZC4gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaW1tZWRpYXRlICYmIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXMpID0+IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgcmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoaXMgZmxhZyB0byB0cnVlIGlmIGFueSBzZXJ2aWNlIHdvcmtlciB3YXMgY29udHJvbGxpbmcgdGhlIHBhZ2VcbiAgICAgICAgLy8gYXQgcmVnaXN0cmF0aW9uIHRpbWUuXG4gICAgICAgIHRoaXMuX2lzVXBkYXRlID0gQm9vbGVhbihuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyKTtcbiAgICAgICAgLy8gQmVmb3JlIHJlZ2lzdGVyaW5nLCBhdHRlbXB0IHRvIGRldGVybWluZSBpZiBhIFNXIGlzIGFscmVhZHkgY29udHJvbGxpbmdcbiAgICAgICAgLy8gdGhlIHBhZ2UsIGFuZCBpZiB0aGF0IFNXIHNjcmlwdCAoYW5kIHZlcnNpb24sIGlmIHNwZWNpZmllZCkgbWF0Y2hlcyB0aGlzXG4gICAgICAgIC8vIGluc3RhbmNlJ3Mgc2NyaXB0LlxuICAgICAgICB0aGlzLl9jb21wYXRpYmxlQ29udHJvbGxpbmdTVyA9IHRoaXMuX2dldENvbnRyb2xsaW5nU1dJZkNvbXBhdGlibGUoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0cmF0aW9uID0gYXdhaXQgdGhpcy5fcmVnaXN0ZXJTY3JpcHQoKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGNvbXBhdGlibGUgY29udHJvbGxlciwgc3RvcmUgdGhlIGNvbnRyb2xsZXIgYXMgdGhlIFwib3duXCJcbiAgICAgICAgLy8gU1csIHJlc29sdmUgYWN0aXZlL2NvbnRyb2xsaW5nIGRlZmVycmVkcyBhbmQgYWRkIG5lY2Vzc2FyeSBsaXN0ZW5lcnMuXG4gICAgICAgIGlmICh0aGlzLl9jb21wYXRpYmxlQ29udHJvbGxpbmdTVykge1xuICAgICAgICAgICAgdGhpcy5fc3cgPSB0aGlzLl9jb21wYXRpYmxlQ29udHJvbGxpbmdTVztcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURlZmVycmVkLnJlc29sdmUodGhpcy5fY29tcGF0aWJsZUNvbnRyb2xsaW5nU1cpO1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbGxpbmdEZWZlcnJlZC5yZXNvbHZlKHRoaXMuX2NvbXBhdGlibGVDb250cm9sbGluZ1NXKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBhdGlibGVDb250cm9sbGluZ1NXLmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRlY2hhbmdlJywgdGhpcy5fb25TdGF0ZUNoYW5nZSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYSB3YWl0aW5nIHNlcnZpY2Ugd29ya2VyIHdpdGggYSBtYXRjaGluZyBVUkwgYmVmb3JlIHRoZVxuICAgICAgICAvLyBgdXBkYXRlZm91bmRgIGV2ZW50IGZpcmVzLCBpdCBsaWtlbHkgbWVhbnMgdGhhdCB0aGlzIHNpdGUgaXMgb3BlblxuICAgICAgICAvLyBpbiBhbm90aGVyIHRhYiwgb3IgdGhlIHVzZXIgcmVmcmVzaGVkIHRoZSBwYWdlIChhbmQgdGh1cyB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gcGFnZSB3YXNuJ3QgZnVsbHkgdW5sb2FkZWQgYmVmb3JlIHRoaXMgcGFnZSBzdGFydGVkIGxvYWRpbmcpLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3ByaW1lcnMvc2VydmljZS13b3JrZXJzL2xpZmVjeWNsZSN3YWl0aW5nXG4gICAgICAgIGNvbnN0IHdhaXRpbmdTVyA9IHRoaXMuX3JlZ2lzdHJhdGlvbi53YWl0aW5nO1xuICAgICAgICBpZiAod2FpdGluZ1NXICYmXG4gICAgICAgICAgICB1cmxzTWF0Y2god2FpdGluZ1NXLnNjcmlwdFVSTCwgdGhpcy5fc2NyaXB0VVJMLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgd2FpdGluZyBTVyBhcyB0aGUgXCJvd25cIiBTdywgZXZlbiBpZiBpdCBtZWFucyBvdmVyd3JpdGluZ1xuICAgICAgICAgICAgLy8gYSBjb21wYXRpYmxlIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICB0aGlzLl9zdyA9IHdhaXRpbmdTVztcbiAgICAgICAgICAgIC8vIFJ1biB0aGlzIGluIHRoZSBuZXh0IG1pY3JvdGFzaywgc28gYW55IGNvZGUgdGhhdCBhZGRzIGFuIGV2ZW50XG4gICAgICAgICAgICAvLyBsaXN0ZW5lciBhZnRlciBhd2FpdGluZyBgcmVnaXN0ZXIoKWAgd2lsbCBnZXQgdGhpcyBldmVudC5cbiAgICAgICAgICAgIGRvbnRXYWl0Rm9yKFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgV29ya2JveEV2ZW50KCd3YWl0aW5nJywge1xuICAgICAgICAgICAgICAgICAgICBzdzogd2FpdGluZ1NXLFxuICAgICAgICAgICAgICAgICAgICB3YXNXYWl0aW5nQmVmb3JlUmVnaXN0ZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdBIHNlcnZpY2Ugd29ya2VyIHdhcyBhbHJlYWR5IHdhaXRpbmcgdG8gYWN0aXZhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmVmb3JlIHRoaXMgc2NyaXB0IHdhcyByZWdpc3RlcmVkLi4uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFuIFwib3duXCIgU1cgaXMgYWxyZWFkeSBzZXQsIHJlc29sdmUgdGhlIGRlZmVycmVkLlxuICAgICAgICBpZiAodGhpcy5fc3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3N3RGVmZXJyZWQucmVzb2x2ZSh0aGlzLl9zdyk7XG4gICAgICAgICAgICB0aGlzLl9vd25TV3MuYWRkKHRoaXMuX3N3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnU3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQgc2VydmljZSB3b3JrZXIuJywgdGhpcy5fc2NyaXB0VVJMLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29tcGF0aWJsZUNvbnRyb2xsaW5nU1cpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdBIHNlcnZpY2Ugd29ya2VyIHdpdGggdGhlIHNhbWUgc2NyaXB0IFVSTCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpcyBhbHJlYWR5IGNvbnRyb2xsaW5nIHRoaXMgcGFnZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnQSBzZXJ2aWNlIHdvcmtlciB3aXRoIGEgZGlmZmVyZW50IHNjcmlwdCBVUkwgaXMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3VycmVudGx5IGNvbnRyb2xsaW5nIHRoZSBwYWdlLiBUaGUgYnJvd3NlciBpcyBub3cgZmV0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAndGhlIG5ldyBzY3JpcHQgbm93Li4uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3VycmVudFBhZ2VJc091dE9mU2NvcGUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVVUkwgPSBuZXcgVVJMKHRoaXMuX3JlZ2lzdGVyT3B0aW9ucy5zY29wZSB8fCB0aGlzLl9zY3JpcHRVUkwudG9TdHJpbmcoKSwgZG9jdW1lbnQuYmFzZVVSSSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVVUkxCYXNlUGF0aCA9IG5ldyBVUkwoJy4vJywgc2NvcGVVUkwuaHJlZikucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFsb2NhdGlvbi5wYXRobmFtZS5zdGFydHNXaXRoKHNjb3BlVVJMQmFzZVBhdGgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFnZUlzT3V0T2ZTY29wZSgpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ1RoZSBjdXJyZW50IHBhZ2UgaXMgbm90IGluIHNjb3BlIGZvciB0aGUgcmVnaXN0ZXJlZCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3NlcnZpY2Ugd29ya2VyLiBXYXMgdGhpcyBhIG1pc3Rha2U/Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVnaXN0cmF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWZvdW5kJywgdGhpcy5fb25VcGRhdGVGb3VuZCk7XG4gICAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRyb2xsZXJjaGFuZ2UnLCB0aGlzLl9vbkNvbnRyb2xsZXJDaGFuZ2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0cmF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIHVwZGF0ZXMgb2YgdGhlIHJlZ2lzdGVyZWQgc2VydmljZSB3b3JrZXIuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JlZ2lzdHJhdGlvbikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgYSBXb3JrYm94IGluc3RhbmNlIHdpdGhvdXQgJyArXG4gICAgICAgICAgICAgICAgICAgICdiZWluZyByZWdpc3RlcmVkLiBSZWdpc3RlciB0aGUgV29ya2JveCBpbnN0YW5jZSBmaXJzdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gdXBkYXRlIHJlZ2lzdHJhdGlvblxuICAgICAgICBhd2FpdCB0aGlzLl9yZWdpc3RyYXRpb24udXBkYXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRvIHRoZSBzZXJ2aWNlIHdvcmtlciByZWdpc3RlcmVkIGJ5IHRoaXMgaW5zdGFuY2UgYXMgc29vbiBhcyBpdFxuICAgICAqIGlzIGFjdGl2ZS4gSWYgYSBzZXJ2aWNlIHdvcmtlciB3YXMgYWxyZWFkeSBjb250cm9sbGluZyBhdCByZWdpc3RyYXRpb25cbiAgICAgKiB0aW1lIHRoZW4gaXQgd2lsbCByZXNvbHZlIHRvIHRoYXQgaWYgdGhlIHNjcmlwdCBVUkxzIChhbmQgb3B0aW9uYWxseVxuICAgICAqIHNjcmlwdCB2ZXJzaW9ucykgbWF0Y2gsIG90aGVyd2lzZSBpdCB3aWxsIHdhaXQgdW50aWwgYW4gdXBkYXRlIGlzIGZvdW5kXG4gICAgICogYW5kIGFjdGl2YXRlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8U2VydmljZVdvcmtlcj59XG4gICAgICovXG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZURlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRvIHRoZSBzZXJ2aWNlIHdvcmtlciByZWdpc3RlcmVkIGJ5IHRoaXMgaW5zdGFuY2UgYXMgc29vbiBhcyBpdFxuICAgICAqIGlzIGNvbnRyb2xsaW5nIHRoZSBwYWdlLiBJZiBhIHNlcnZpY2Ugd29ya2VyIHdhcyBhbHJlYWR5IGNvbnRyb2xsaW5nIGF0XG4gICAgICogcmVnaXN0cmF0aW9uIHRpbWUgdGhlbiBpdCB3aWxsIHJlc29sdmUgdG8gdGhhdCBpZiB0aGUgc2NyaXB0IFVSTHMgKGFuZFxuICAgICAqIG9wdGlvbmFsbHkgc2NyaXB0IHZlcnNpb25zKSBtYXRjaCwgb3RoZXJ3aXNlIGl0IHdpbGwgd2FpdCB1bnRpbCBhbiB1cGRhdGVcbiAgICAgKiBpcyBmb3VuZCBhbmQgc3RhcnRzIGNvbnRyb2xsaW5nIHRoZSBwYWdlLlxuICAgICAqIE5vdGU6IHRoZSBmaXJzdCB0aW1lIGEgc2VydmljZSB3b3JrZXIgaXMgaW5zdGFsbGVkIGl0IHdpbGwgYWN0aXZlIGJ1dFxuICAgICAqIG5vdCBzdGFydCBjb250cm9sbGluZyB0aGUgcGFnZSB1bmxlc3MgYGNsaWVudHMuY2xhaW0oKWAgaXMgY2FsbGVkIGluIHRoZVxuICAgICAqIHNlcnZpY2Ugd29ya2VyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxTZXJ2aWNlV29ya2VyPn1cbiAgICAgKi9cbiAgICBnZXQgY29udHJvbGxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250cm9sbGluZ0RlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHdpdGggYSByZWZlcmVuY2UgdG8gYSBzZXJ2aWNlIHdvcmtlciB0aGF0IG1hdGNoZXMgdGhlIHNjcmlwdCBVUkxcbiAgICAgKiBvZiB0aGlzIGluc3RhbmNlLCBhcyBzb29uIGFzIGl0J3MgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogSWYsIGF0IHJlZ2lzdHJhdGlvbiB0aW1lLCB0aGVyZSdzIGFscmVhZHkgYW4gYWN0aXZlIG9yIHdhaXRpbmcgc2VydmljZVxuICAgICAqIHdvcmtlciB3aXRoIGEgbWF0Y2hpbmcgc2NyaXB0IFVSTCwgaXQgd2lsbCBiZSB1c2VkICh3aXRoIHRoZSB3YWl0aW5nXG4gICAgICogc2VydmljZSB3b3JrZXIgdGFraW5nIHByZWNlZGVuY2Ugb3ZlciB0aGUgYWN0aXZlIHNlcnZpY2Ugd29ya2VyIGlmIGJvdGhcbiAgICAgKiBtYXRjaCwgc2luY2UgdGhlIHdhaXRpbmcgc2VydmljZSB3b3JrZXIgd291bGQgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgbW9yZVxuICAgICAqIHJlY2VudGx5KS5cbiAgICAgKiBJZiB0aGVyZSdzIG5vIG1hdGNoaW5nIGFjdGl2ZSBvciB3YWl0aW5nIHNlcnZpY2Ugd29ya2VyIGF0IHJlZ2lzdHJhdGlvblxuICAgICAqIHRpbWUgdGhlbiB0aGUgcHJvbWlzZSB3aWxsIG5vdCByZXNvbHZlIHVudGlsIGFuIHVwZGF0ZSBpcyBmb3VuZCBhbmQgc3RhcnRzXG4gICAgICogaW5zdGFsbGluZywgYXQgd2hpY2ggcG9pbnQgdGhlIGluc3RhbGxpbmcgc2VydmljZSB3b3JrZXIgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8U2VydmljZVdvcmtlcj59XG4gICAgICovXG4gICAgZ2V0U1coKSB7XG4gICAgICAgIC8vIElmIGB0aGlzLl9zd2AgaXMgc2V0LCByZXNvbHZlIHdpdGggdGhhdCBhcyB3ZSB3YW50IGBnZXRTVygpYCB0b1xuICAgICAgICAvLyByZXR1cm4gdGhlIGNvcnJlY3QgKG5ldykgc2VydmljZSB3b3JrZXIgaWYgYW4gdXBkYXRlIGlzIGZvdW5kLlxuICAgICAgICByZXR1cm4gdGhpcy5fc3cgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUodGhpcy5fc3cpXG4gICAgICAgICAgICA6IHRoaXMuX3N3RGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgdGhlIHBhc3NlZCBkYXRhIG9iamVjdCB0byB0aGUgc2VydmljZSB3b3JrZXIgcmVnaXN0ZXJlZCBieSB0aGlzXG4gICAgICogaW5zdGFuY2UgKHZpYSB7QGxpbmsgd29ya2JveC13aW5kb3cuV29ya2JveCNnZXRTV30pIGFuZCByZXNvbHZlc1xuICAgICAqIHdpdGggYSByZXNwb25zZSAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIEEgcmVzcG9uc2UgY2FuIGJlIHNldCBpbiBhIG1lc3NhZ2UgaGFuZGxlciBpbiB0aGUgc2VydmljZSB3b3JrZXIgYnlcbiAgICAgKiBjYWxsaW5nIGBldmVudC5wb3J0c1swXS5wb3N0TWVzc2FnZSguLi4pYCwgd2hpY2ggd2lsbCByZXNvbHZlIHRoZSBwcm9taXNlXG4gICAgICogcmV0dXJuZWQgYnkgYG1lc3NhZ2VTVygpYC4gSWYgbm8gcmVzcG9uc2UgaXMgc2V0LCB0aGUgcHJvbWlzZSB3aWxsIG5ldmVyXG4gICAgICogcmVzb2x2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCB0byBzZW5kIHRvIHRoZSBzZXJ2aWNlIHdvcmtlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICAvLyBXZSBtaWdodCBiZSBhYmxlIHRvIGNoYW5nZSB0aGUgJ2RhdGEnIHR5cGUgdG8gUmVjb3JkPHN0cmluZywgdW5rbm93bj4gaW4gdGhlIGZ1dHVyZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIGFzeW5jIG1lc3NhZ2VTVyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IHN3ID0gYXdhaXQgdGhpcy5nZXRTVygpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZVNXKHN3LCBkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBge3R5cGU6ICdTS0lQX1dBSVRJTkcnfWAgbWVzc2FnZSB0byB0aGUgc2VydmljZSB3b3JrZXIgdGhhdCdzXG4gICAgICogY3VycmVudGx5IGluIHRoZSBgd2FpdGluZ2Agc3RhdGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IHJlZ2lzdHJhdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGlzIG5vIGN1cnJlbnQgcmVnaXN0cmF0aW9uIG9yIG5vIHNlcnZpY2Ugd29ya2VyIGlzIGB3YWl0aW5nYCxcbiAgICAgKiBjYWxsaW5nIHRoaXMgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgKi9cbiAgICBtZXNzYWdlU2tpcFdhaXRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWdpc3RyYXRpb24gJiYgdGhpcy5fcmVnaXN0cmF0aW9uLndhaXRpbmcpIHtcbiAgICAgICAgICAgIHZvaWQgbWVzc2FnZVNXKHRoaXMuX3JlZ2lzdHJhdGlvbi53YWl0aW5nLCBTS0lQX1dBSVRJTkdfTUVTU0FHRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciBhIHNlcnZpY2Ugd29ya2VyIGFscmVhZHkgY29udHJvbGxpbmcgdGhlIHBhZ2UgYW5kIHJldHVybnNcbiAgICAgKiBpdCBpZiBpdHMgc2NyaXB0IFVSTCBtYXRjaGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtTZXJ2aWNlV29ya2VyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBfZ2V0Q29udHJvbGxpbmdTV0lmQ29tcGF0aWJsZSgpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChjb250cm9sbGVyICYmXG4gICAgICAgICAgICB1cmxzTWF0Y2goY29udHJvbGxlci5zY3JpcHRVUkwsIHRoaXMuX3NjcmlwdFVSTC50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHNlcnZpY2Ugd29ya2VyIGZvciB0aGlzIGluc3RhbmNlcyBzY3JpcHQgVVJMIGFuZCByZWdpc3RlclxuICAgICAqIG9wdGlvbnMgYW5kIHRyYWNrcyB0aGUgdGltZSByZWdpc3RyYXRpb24gd2FzIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfcmVnaXN0ZXJTY3JpcHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB0aGlzLl9zY3JpcHRVUkwgbWF5IGJlIGEgVHJ1c3RlZFNjcmlwdFVSTCwgYnV0IHRoZXJlJ3Mgbm8gc3VwcG9ydCBmb3JcbiAgICAgICAgICAgIC8vIHBhc3NpbmcgdGhhdCB0byByZWdpc3RlcigpIGluIGxpYi5kb20gcmlnaHQgbm93LlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8yODU1XG4gICAgICAgICAgICBjb25zdCByZWcgPSBhd2FpdCBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3Rlcih0aGlzLl9zY3JpcHRVUkwsIHRoaXMuX3JlZ2lzdGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHdoZW4gcmVnaXN0cmF0aW9uIGhhcHBlbmVkLCBzbyBpdCBjYW4gYmUgdXNlZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIGB0aGlzLl9vblVwZGF0ZUZvdW5kYCBoZXVyaXN0aWMuIEFsc28gdXNlIHRoZSBwcmVzZW5jZSBvZiB0aGlzXG4gICAgICAgICAgICAvLyBwcm9wZXJ0eSBhcyBhIHdheSB0byBzZWUgaWYgYC5yZWdpc3RlcigpYCBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RyYXRpb25UaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVnO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlIGVycm9yLlxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgeyBXb3JrYm94IH07XG4vLyBUaGUganNkb2MgY29tbWVudHMgYmVsb3cgb3V0bGluZSB0aGUgZXZlbnRzIHRoaXMgaW5zdGFuY2UgbWF5IGRpc3BhdGNoOlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogVGhlIGBtZXNzYWdlYCBldmVudCBpcyBkaXNwYXRjaGVkIGFueSB0aW1lIGEgYHBvc3RNZXNzYWdlYCBpcyByZWNlaXZlZC5cbiAqXG4gKiBAZXZlbnQgd29ya2JveC13aW5kb3cuV29ya2JveCNtZXNzYWdlXG4gKiBAdHlwZSB7V29ya2JveEV2ZW50fVxuICogQHByb3BlcnR5IHsqfSBkYXRhIFRoZSBgZGF0YWAgcHJvcGVydHkgZnJvbSB0aGUgb3JpZ2luYWwgYG1lc3NhZ2VgIGV2ZW50LlxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudCBUaGUgb3JpZ2luYWwgW2BtZXNzYWdlYF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lc3NhZ2VFdmVudH1cbiAqICAgICBldmVudC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIGBtZXNzYWdlYC5cbiAqIEBwcm9wZXJ0eSB7TWVzc2FnZVBvcnRbXX0gcG9ydHMgVGhlIGBwb3J0c2AgdmFsdWUgZnJvbSBgb3JpZ2luYWxFdmVudGAuXG4gKiBAcHJvcGVydHkge1dvcmtib3h9IHRhcmdldCBUaGUgYFdvcmtib3hgIGluc3RhbmNlLlxuICovXG4vKipcbiAqIFRoZSBgaW5zdGFsbGVkYCBldmVudCBpcyBkaXNwYXRjaGVkIGlmIHRoZSBzdGF0ZSBvZiBhXG4gKiB7QGxpbmsgd29ya2JveC13aW5kb3cuV29ya2JveH0gaW5zdGFuY2Unc1xuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi90b29scy93b3JrYm94L21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nI2RlZi1yZWdpc3RlcmVkLXN3fHJlZ2lzdGVyZWQgc2VydmljZSB3b3JrZXJ9XG4gKiBjaGFuZ2VzIHRvIGBpbnN0YWxsZWRgLlxuICpcbiAqIFRoZW4gY2FuIGhhcHBlbiBlaXRoZXIgdGhlIHZlcnkgZmlyc3QgdGltZSBhIHNlcnZpY2Ugd29ya2VyIGlzIGluc3RhbGxlZCxcbiAqIG9yIGFmdGVyIGFuIHVwZGF0ZSB0byB0aGUgY3VycmVudCBzZXJ2aWNlIHdvcmtlciBpcyBmb3VuZC4gSW4gdGhlIGNhc2VcbiAqIG9mIGFuIHVwZGF0ZSBiZWluZyBmb3VuZCwgdGhlIGV2ZW50J3MgYGlzVXBkYXRlYCBwcm9wZXJ0eSB3aWxsIGJlIGB0cnVlYC5cbiAqXG4gKiBAZXZlbnQgd29ya2JveC13aW5kb3cuV29ya2JveCNpbnN0YWxsZWRcbiAqIEB0eXBlIHtXb3JrYm94RXZlbnR9XG4gKiBAcHJvcGVydHkge1NlcnZpY2VXb3JrZXJ9IHN3IFRoZSBzZXJ2aWNlIHdvcmtlciBpbnN0YW5jZS5cbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgVGhlIG9yaWdpbmFsIFtgc3RhdGVjaGFuZ2VgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmljZVdvcmtlci9vbnN0YXRlY2hhbmdlfVxuICogICAgIGV2ZW50LlxuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gaXNVcGRhdGUgVHJ1ZSBpZiBhIHNlcnZpY2Ugd29ya2VyIHdhcyBhbHJlYWR5XG4gKiAgICAgY29udHJvbGxpbmcgd2hlbiB0aGlzIGBXb3JrYm94YCBpbnN0YW5jZSBjYWxsZWQgYHJlZ2lzdGVyKClgLlxuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gaXNFeHRlcm5hbCBUcnVlIGlmIHRoaXMgZXZlbnQgaXMgYXNzb2NpYXRlZFxuICogICAgIHdpdGggYW4gW2V4dGVybmFsIHNlcnZpY2Ugd29ya2VyXXtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdG9vbHMvd29ya2JveC9tb2R1bGVzL3dvcmtib3gtd2luZG93I3doZW5fYW5fdW5leHBlY3RlZF92ZXJzaW9uX29mX3RoZV9zZXJ2aWNlX3dvcmtlcl9pc19mb3VuZH0uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBgaW5zdGFsbGVkYC5cbiAqIEBwcm9wZXJ0eSB7V29ya2JveH0gdGFyZ2V0IFRoZSBgV29ya2JveGAgaW5zdGFuY2UuXG4gKi9cbi8qKlxuICogVGhlIGB3YWl0aW5nYCBldmVudCBpcyBkaXNwYXRjaGVkIGlmIHRoZSBzdGF0ZSBvZiBhXG4gKiB7QGxpbmsgd29ya2JveC13aW5kb3cuV29ya2JveH0gaW5zdGFuY2Unc1xuICogW3JlZ2lzdGVyZWQgc2VydmljZSB3b3JrZXJde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi90b29scy93b3JrYm94L21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nI2RlZi1yZWdpc3RlcmVkLXN3fVxuICogY2hhbmdlcyB0byBgaW5zdGFsbGVkYCBhbmQgdGhlbiBkb2Vzbid0IGltbWVkaWF0ZWx5IGNoYW5nZSB0byBgYWN0aXZhdGluZ2AuXG4gKiBJdCBtYXkgYWxzbyBiZSBkaXNwYXRjaGVkIGlmIGEgc2VydmljZSB3b3JrZXIgd2l0aCB0aGUgc2FtZVxuICogW2BzY3JpcHRVUkxgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmljZVdvcmtlci9zY3JpcHRVUkx9XG4gKiB3YXMgYWxyZWFkeSB3YWl0aW5nIHdoZW4gdGhlIHtAbGluayB3b3JrYm94LXdpbmRvdy5Xb3JrYm94I3JlZ2lzdGVyfVxuICogbWV0aG9kIHdhcyBjYWxsZWQuXG4gKlxuICogQGV2ZW50IHdvcmtib3gtd2luZG93Lldvcmtib3gjd2FpdGluZ1xuICogQHR5cGUge1dvcmtib3hFdmVudH1cbiAqIEBwcm9wZXJ0eSB7U2VydmljZVdvcmtlcn0gc3cgVGhlIHNlcnZpY2Ugd29ya2VyIGluc3RhbmNlLlxuICogQHByb3BlcnR5IHtFdmVudHx1bmRlZmluZWR9IG9yaWdpbmFsRXZlbnQgVGhlIG9yaWdpbmFsXG4gKiAgICBbYHN0YXRlY2hhbmdlYF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZpY2VXb3JrZXIvb25zdGF0ZWNoYW5nZX1cbiAqICAgICBldmVudCwgb3IgYHVuZGVmaW5lZGAgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHNlcnZpY2Ugd29ya2VyIHdhcyB3YWl0aW5nXG4gKiAgICAgdG8gYmVmb3JlIGAucmVnaXN0ZXIoKWAgd2FzIGNhbGxlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnx1bmRlZmluZWR9IGlzVXBkYXRlIFRydWUgaWYgYSBzZXJ2aWNlIHdvcmtlciB3YXMgYWxyZWFkeVxuICogICAgIGNvbnRyb2xsaW5nIHdoZW4gdGhpcyBgV29ya2JveGAgaW5zdGFuY2UgY2FsbGVkIGByZWdpc3RlcigpYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnx1bmRlZmluZWR9IGlzRXh0ZXJuYWwgVHJ1ZSBpZiB0aGlzIGV2ZW50IGlzIGFzc29jaWF0ZWRcbiAqICAgICB3aXRoIGFuIFtleHRlcm5hbCBzZXJ2aWNlIHdvcmtlcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3Rvb2xzL3dvcmtib3gvbW9kdWxlcy93b3JrYm94LXdpbmRvdyN3aGVuX2FuX3VuZXhwZWN0ZWRfdmVyc2lvbl9vZl90aGVfc2VydmljZV93b3JrZXJfaXNfZm91bmR9LlxuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gd2FzV2FpdGluZ0JlZm9yZVJlZ2lzdGVyIFRydWUgaWYgYSBzZXJ2aWNlIHdvcmtlciB3aXRoXG4gKiAgICAgYSBtYXRjaGluZyBgc2NyaXB0VVJMYCB3YXMgYWxyZWFkeSB3YWl0aW5nIHdoZW4gdGhpcyBgV29ya2JveGBcbiAqICAgICBpbnN0YW5jZSBjYWxsZWQgYHJlZ2lzdGVyKClgLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgYHdhaXRpbmdgLlxuICogQHByb3BlcnR5IHtXb3JrYm94fSB0YXJnZXQgVGhlIGBXb3JrYm94YCBpbnN0YW5jZS5cbiAqL1xuLyoqXG4gKiBUaGUgYGNvbnRyb2xsaW5nYCBldmVudCBpcyBkaXNwYXRjaGVkIGlmIGFcbiAqIFtgY29udHJvbGxlcmNoYW5nZWBde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2aWNlV29ya2VyQ29udGFpbmVyL29uY29udHJvbGxlcmNoYW5nZX1cbiAqIGZpcmVzIG9uIHRoZSBzZXJ2aWNlIHdvcmtlciBbY29udGFpbmVyXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmljZVdvcmtlckNvbnRhaW5lcn1cbiAqIGFuZCB0aGUgW2BzY3JpcHRVUkxgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmljZVdvcmtlci9zY3JpcHRVUkx9XG4gKiBvZiB0aGUgbmV3IFtjb250cm9sbGVyXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmljZVdvcmtlckNvbnRhaW5lci9jb250cm9sbGVyfVxuICogbWF0Y2hlcyB0aGUgYHNjcmlwdFVSTGAgb2YgdGhlIGBXb3JrYm94YCBpbnN0YW5jZSdzXG4gKiBbcmVnaXN0ZXJlZCBzZXJ2aWNlIHdvcmtlcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3Rvb2xzL3dvcmtib3gvbW9kdWxlcy93b3JrYm94LXByZWNhY2hpbmcjZGVmLXJlZ2lzdGVyZWQtc3d9LlxuICpcbiAqIEBldmVudCB3b3JrYm94LXdpbmRvdy5Xb3JrYm94I2NvbnRyb2xsaW5nXG4gKiBAdHlwZSB7V29ya2JveEV2ZW50fVxuICogQHByb3BlcnR5IHtTZXJ2aWNlV29ya2VyfSBzdyBUaGUgc2VydmljZSB3b3JrZXIgaW5zdGFuY2UuXG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50IFRoZSBvcmlnaW5hbCBbYGNvbnRyb2xsZXJjaGFuZ2VgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmljZVdvcmtlckNvbnRhaW5lci9vbmNvbnRyb2xsZXJjaGFuZ2V9XG4gKiAgICAgZXZlbnQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58dW5kZWZpbmVkfSBpc1VwZGF0ZSBUcnVlIGlmIGEgc2VydmljZSB3b3JrZXIgd2FzIGFscmVhZHlcbiAqICAgICBjb250cm9sbGluZyB3aGVuIHRoaXMgc2VydmljZSB3b3JrZXIgd2FzIHJlZ2lzdGVyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58dW5kZWZpbmVkfSBpc0V4dGVybmFsIFRydWUgaWYgdGhpcyBldmVudCBpcyBhc3NvY2lhdGVkXG4gKiAgICAgd2l0aCBhbiBbZXh0ZXJuYWwgc2VydmljZSB3b3JrZXJde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi90b29scy93b3JrYm94L21vZHVsZXMvd29ya2JveC13aW5kb3cjd2hlbl9hbl91bmV4cGVjdGVkX3ZlcnNpb25fb2ZfdGhlX3NlcnZpY2Vfd29ya2VyX2lzX2ZvdW5kfS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIGBjb250cm9sbGluZ2AuXG4gKiBAcHJvcGVydHkge1dvcmtib3h9IHRhcmdldCBUaGUgYFdvcmtib3hgIGluc3RhbmNlLlxuICovXG4vKipcbiAqIFRoZSBgYWN0aXZhdGVkYCBldmVudCBpcyBkaXNwYXRjaGVkIGlmIHRoZSBzdGF0ZSBvZiBhXG4gKiB7QGxpbmsgd29ya2JveC13aW5kb3cuV29ya2JveH0gaW5zdGFuY2Unc1xuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi90b29scy93b3JrYm94L21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nI2RlZi1yZWdpc3RlcmVkLXN3fHJlZ2lzdGVyZWQgc2VydmljZSB3b3JrZXJ9XG4gKiBjaGFuZ2VzIHRvIGBhY3RpdmF0ZWRgLlxuICpcbiAqIEBldmVudCB3b3JrYm94LXdpbmRvdy5Xb3JrYm94I2FjdGl2YXRlZFxuICogQHR5cGUge1dvcmtib3hFdmVudH1cbiAqIEBwcm9wZXJ0eSB7U2VydmljZVdvcmtlcn0gc3cgVGhlIHNlcnZpY2Ugd29ya2VyIGluc3RhbmNlLlxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudCBUaGUgb3JpZ2luYWwgW2BzdGF0ZWNoYW5nZWBde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2aWNlV29ya2VyL29uc3RhdGVjaGFuZ2V9XG4gKiAgICAgZXZlbnQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58dW5kZWZpbmVkfSBpc1VwZGF0ZSBUcnVlIGlmIGEgc2VydmljZSB3b3JrZXIgd2FzIGFscmVhZHlcbiAqICAgICBjb250cm9sbGluZyB3aGVuIHRoaXMgYFdvcmtib3hgIGluc3RhbmNlIGNhbGxlZCBgcmVnaXN0ZXIoKWAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58dW5kZWZpbmVkfSBpc0V4dGVybmFsIFRydWUgaWYgdGhpcyBldmVudCBpcyBhc3NvY2lhdGVkXG4gKiAgICAgd2l0aCBhbiBbZXh0ZXJuYWwgc2VydmljZSB3b3JrZXJde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi90b29scy93b3JrYm94L21vZHVsZXMvd29ya2JveC13aW5kb3cjd2hlbl9hbl91bmV4cGVjdGVkX3ZlcnNpb25fb2ZfdGhlX3NlcnZpY2Vfd29ya2VyX2lzX2ZvdW5kfS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIGBhY3RpdmF0ZWRgLlxuICogQHByb3BlcnR5IHtXb3JrYm94fSB0YXJnZXQgVGhlIGBXb3JrYm94YCBpbnN0YW5jZS5cbiAqL1xuLyoqXG4gKiBUaGUgYHJlZHVuZGFudGAgZXZlbnQgaXMgZGlzcGF0Y2hlZCBpZiB0aGUgc3RhdGUgb2YgYVxuICoge0BsaW5rIHdvcmtib3gtd2luZG93Lldvcmtib3h9IGluc3RhbmNlJ3NcbiAqIFtyZWdpc3RlcmVkIHNlcnZpY2Ugd29ya2VyXXtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdG9vbHMvd29ya2JveC9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZyNkZWYtcmVnaXN0ZXJlZC1zd31cbiAqIGNoYW5nZXMgdG8gYHJlZHVuZGFudGAuXG4gKlxuICogQGV2ZW50IHdvcmtib3gtd2luZG93Lldvcmtib3gjcmVkdW5kYW50XG4gKiBAdHlwZSB7V29ya2JveEV2ZW50fVxuICogQHByb3BlcnR5IHtTZXJ2aWNlV29ya2VyfSBzdyBUaGUgc2VydmljZSB3b3JrZXIgaW5zdGFuY2UuXG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50IFRoZSBvcmlnaW5hbCBbYHN0YXRlY2hhbmdlYF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZpY2VXb3JrZXIvb25zdGF0ZWNoYW5nZX1cbiAqICAgICBldmVudC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnx1bmRlZmluZWR9IGlzVXBkYXRlIFRydWUgaWYgYSBzZXJ2aWNlIHdvcmtlciB3YXMgYWxyZWFkeVxuICogICAgIGNvbnRyb2xsaW5nIHdoZW4gdGhpcyBgV29ya2JveGAgaW5zdGFuY2UgY2FsbGVkIGByZWdpc3RlcigpYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIGByZWR1bmRhbnRgLlxuICogQHByb3BlcnR5IHtXb3JrYm94fSB0YXJnZXQgVGhlIGBXb3JrYm94YCBpbnN0YW5jZS5cbiAqL1xuIiwiZXhwb3J0ICogZnJvbSAnLi9Xb3JrYm94LmpzJzsiLCJjb25zdCBpbnN0YW5jZU9mQW55ID0gKG9iamVjdCwgY29uc3RydWN0b3JzKSA9PiBjb25zdHJ1Y3RvcnMuc29tZSgoYykgPT4gb2JqZWN0IGluc3RhbmNlb2YgYyk7XG5cbmxldCBpZGJQcm94eWFibGVUeXBlcztcbmxldCBjdXJzb3JBZHZhbmNlTWV0aG9kcztcbi8vIFRoaXMgaXMgYSBmdW5jdGlvbiB0byBwcmV2ZW50IGl0IHRocm93aW5nIHVwIGluIG5vZGUgZW52aXJvbm1lbnRzLlxuZnVuY3Rpb24gZ2V0SWRiUHJveHlhYmxlVHlwZXMoKSB7XG4gICAgcmV0dXJuIChpZGJQcm94eWFibGVUeXBlcyB8fFxuICAgICAgICAoaWRiUHJveHlhYmxlVHlwZXMgPSBbXG4gICAgICAgICAgICBJREJEYXRhYmFzZSxcbiAgICAgICAgICAgIElEQk9iamVjdFN0b3JlLFxuICAgICAgICAgICAgSURCSW5kZXgsXG4gICAgICAgICAgICBJREJDdXJzb3IsXG4gICAgICAgICAgICBJREJUcmFuc2FjdGlvbixcbiAgICAgICAgXSkpO1xufVxuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXG5mdW5jdGlvbiBnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcygpIHtcbiAgICByZXR1cm4gKGN1cnNvckFkdmFuY2VNZXRob2RzIHx8XG4gICAgICAgIChjdXJzb3JBZHZhbmNlTWV0aG9kcyA9IFtcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuYWR2YW5jZSxcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuY29udGludWUsXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlUHJpbWFyeUtleSxcbiAgICAgICAgXSkpO1xufVxuY29uc3QgY3Vyc29yUmVxdWVzdE1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2FjdGlvbkRvbmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJldmVyc2VUcmFuc2Zvcm1DYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBwcm9taXNpZnlSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxpc3RlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3VjY2VzcycsIHN1Y2Nlc3MpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUod3JhcChyZXF1ZXN0LnJlc3VsdCkpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBzdWNjZXNzKTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICB9KTtcbiAgICBwcm9taXNlXG4gICAgICAgIC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBTaW5jZSBjdXJzb3JpbmcgcmV1c2VzIHRoZSBJREJSZXF1ZXN0ICgqc2lnaCopLCB3ZSBjYWNoZSBpdCBmb3IgbGF0ZXIgcmV0cmlldmFsXG4gICAgICAgIC8vIChzZWUgd3JhcEZ1bmN0aW9uKS5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCQ3Vyc29yKSB7XG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0TWFwLnNldCh2YWx1ZSwgcmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2F0Y2hpbmcgdG8gYXZvaWQgXCJVbmNhdWdodCBQcm9taXNlIGV4Y2VwdGlvbnNcIlxuICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgIC8vIFRoaXMgbWFwcGluZyBleGlzdHMgaW4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlIGJ1dCBkb2Vzbid0IGRvZXNuJ3QgZXhpc3QgaW4gdHJhbnNmb3JtQ2FjaGUuIFRoaXNcbiAgICAvLyBpcyBiZWNhdXNlIHdlIGNyZWF0ZSBtYW55IHByb21pc2VzIGZyb20gYSBzaW5nbGUgSURCUmVxdWVzdC5cbiAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KHByb21pc2UsIHJlcXVlc3QpO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gY2FjaGVEb25lUHJvbWlzZUZvclRyYW5zYWN0aW9uKHR4KSB7XG4gICAgLy8gRWFybHkgYmFpbCBpZiB3ZSd2ZSBhbHJlYWR5IGNyZWF0ZWQgYSBkb25lIHByb21pc2UgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgaWYgKHRyYW5zYWN0aW9uRG9uZU1hcC5oYXModHgpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgZG9uZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdW5saXN0ZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QodHguZXJyb3IgfHwgbmV3IERPTUV4Y2VwdGlvbignQWJvcnRFcnJvcicsICdBYm9ydEVycm9yJykpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCBjb21wbGV0ZSk7XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVycm9yKTtcbiAgICB9KTtcbiAgICAvLyBDYWNoZSBpdCBmb3IgbGF0ZXIgcmV0cmlldmFsLlxuICAgIHRyYW5zYWN0aW9uRG9uZU1hcC5zZXQodHgsIGRvbmUpO1xufVxubGV0IGlkYlByb3h5VHJhcHMgPSB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciB0cmFuc2FjdGlvbi5kb25lLlxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdkb25lJylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25Eb25lTWFwLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgLy8gUG9seWZpbGwgZm9yIG9iamVjdFN0b3JlTmFtZXMgYmVjYXVzZSBvZiBFZGdlLlxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdvYmplY3RTdG9yZU5hbWVzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQub2JqZWN0U3RvcmVOYW1lcyB8fCB0cmFuc2FjdGlvblN0b3JlTmFtZXNNYXAuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHR4LnN0b3JlIHJldHVybiB0aGUgb25seSBzdG9yZSBpbiB0aGUgdHJhbnNhY3Rpb24sIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbWFueS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnc3RvcmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiByZWNlaXZlci5vYmplY3RTdG9yZShyZWNlaXZlci5vYmplY3RTdG9yZU5hbWVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlIHRyYW5zZm9ybSB3aGF0ZXZlciB3ZSBnZXQgYmFjay5cbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0W3Byb3BdKTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uICYmXG4gICAgICAgICAgICAocHJvcCA9PT0gJ2RvbmUnIHx8IHByb3AgPT09ICdzdG9yZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcCBpbiB0YXJnZXQ7XG4gICAgfSxcbn07XG5mdW5jdGlvbiByZXBsYWNlVHJhcHMoY2FsbGJhY2spIHtcbiAgICBpZGJQcm94eVRyYXBzID0gY2FsbGJhY2soaWRiUHJveHlUcmFwcyk7XG59XG5mdW5jdGlvbiB3cmFwRnVuY3Rpb24oZnVuYykge1xuICAgIC8vIER1ZSB0byBleHBlY3RlZCBvYmplY3QgZXF1YWxpdHkgKHdoaWNoIGlzIGVuZm9yY2VkIGJ5IHRoZSBjYWNoaW5nIGluIGB3cmFwYCksIHdlXG4gICAgLy8gb25seSBjcmVhdGUgb25lIG5ldyBmdW5jIHBlciBmdW5jLlxuICAgIC8vIEVkZ2UgZG9lc24ndCBzdXBwb3J0IG9iamVjdFN0b3JlTmFtZXMgKGJvb28pLCBzbyB3ZSBwb2x5ZmlsbCBpdCBoZXJlLlxuICAgIGlmIChmdW5jID09PSBJREJEYXRhYmFzZS5wcm90b3R5cGUudHJhbnNhY3Rpb24gJiZcbiAgICAgICAgISgnb2JqZWN0U3RvcmVOYW1lcycgaW4gSURCVHJhbnNhY3Rpb24ucHJvdG90eXBlKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0b3JlTmFtZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gZnVuYy5jYWxsKHVud3JhcCh0aGlzKSwgc3RvcmVOYW1lcywgLi4uYXJncyk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvblN0b3JlTmFtZXNNYXAuc2V0KHR4LCBzdG9yZU5hbWVzLnNvcnQgPyBzdG9yZU5hbWVzLnNvcnQoKSA6IFtzdG9yZU5hbWVzXSk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcCh0eCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEN1cnNvciBtZXRob2RzIGFyZSBzcGVjaWFsLCBhcyB0aGUgYmVoYXZpb3VyIGlzIGEgbGl0dGxlIG1vcmUgZGlmZmVyZW50IHRvIHN0YW5kYXJkIElEQi4gSW5cbiAgICAvLyBJREIsIHlvdSBhZHZhbmNlIHRoZSBjdXJzb3IgYW5kIHdhaXQgZm9yIGEgbmV3ICdzdWNjZXNzJyBvbiB0aGUgSURCUmVxdWVzdCB0aGF0IGdhdmUgeW91IHRoZVxuICAgIC8vIGN1cnNvci4gSXQncyBraW5kYSBsaWtlIGEgcHJvbWlzZSB0aGF0IGNhbiByZXNvbHZlIHdpdGggbWFueSB2YWx1ZXMuIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlXG4gICAgLy8gd2l0aCByZWFsIHByb21pc2VzLCBzbyBlYWNoIGFkdmFuY2UgbWV0aG9kcyByZXR1cm5zIGEgbmV3IHByb21pc2UgZm9yIHRoZSBjdXJzb3Igb2JqZWN0LCBvclxuICAgIC8vIHVuZGVmaW5lZCBpZiB0aGUgZW5kIG9mIHRoZSBjdXJzb3IgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICBpZiAoZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKS5pbmNsdWRlcyhmdW5jKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3h5IGFzICd0aGlzJyBjYXVzZXMgSUxMRUdBTCBJTlZPQ0FUSU9OLCBzbyB3ZSB1c2VcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgICAgICBmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcChjdXJzb3JSZXF1ZXN0TWFwLmdldCh0aGlzKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgIHJldHVybiB3cmFwKGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUNhY2hhYmxlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gd3JhcEZ1bmN0aW9uKHZhbHVlKTtcbiAgICAvLyBUaGlzIGRvZXNuJ3QgcmV0dXJuLCBpdCBqdXN0IGNyZWF0ZXMgYSAnZG9uZScgcHJvbWlzZSBmb3IgdGhlIHRyYW5zYWN0aW9uLFxuICAgIC8vIHdoaWNoIGlzIGxhdGVyIHJldHVybmVkIGZvciB0cmFuc2FjdGlvbi5kb25lIChzZWUgaWRiT2JqZWN0SGFuZGxlcikuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pXG4gICAgICAgIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih2YWx1ZSk7XG4gICAgaWYgKGluc3RhbmNlT2ZBbnkodmFsdWUsIGdldElkYlByb3h5YWJsZVR5cGVzKCkpKVxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHZhbHVlLCBpZGJQcm94eVRyYXBzKTtcbiAgICAvLyBSZXR1cm4gdGhlIHNhbWUgdmFsdWUgYmFjayBpZiB3ZSdyZSBub3QgZ29pbmcgdG8gdHJhbnNmb3JtIGl0LlxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHdyYXAodmFsdWUpIHtcbiAgICAvLyBXZSBzb21ldGltZXMgZ2VuZXJhdGUgbXVsdGlwbGUgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0IChlZyB3aGVuIGN1cnNvcmluZyksIGJlY2F1c2VcbiAgICAvLyBJREIgaXMgd2VpcmQgYW5kIGEgc2luZ2xlIElEQlJlcXVlc3QgY2FuIHlpZWxkIG1hbnkgcmVzcG9uc2VzLCBzbyB0aGVzZSBjYW4ndCBiZSBjYWNoZWQuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCUmVxdWVzdClcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeVJlcXVlc3QodmFsdWUpO1xuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgdHJhbnNmb3JtZWQgdGhpcyB2YWx1ZSBiZWZvcmUsIHJldXNlIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZS5cbiAgICAvLyBUaGlzIGlzIGZhc3RlciwgYnV0IGl0IGFsc28gcHJvdmlkZXMgb2JqZWN0IGVxdWFsaXR5LlxuICAgIGlmICh0cmFuc2Zvcm1DYWNoZS5oYXModmFsdWUpKVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtQ2FjaGUuZ2V0KHZhbHVlKTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRyYW5zZm9ybUNhY2hhYmxlVmFsdWUodmFsdWUpO1xuICAgIC8vIE5vdCBhbGwgdHlwZXMgYXJlIHRyYW5zZm9ybWVkLlxuICAgIC8vIFRoZXNlIG1heSBiZSBwcmltaXRpdmUgdHlwZXMsIHNvIHRoZXkgY2FuJ3QgYmUgV2Vha01hcCBrZXlzLlxuICAgIGlmIChuZXdWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdHJhbnNmb3JtQ2FjaGUuc2V0KHZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQobmV3VmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufVxuY29uc3QgdW53cmFwID0gKHZhbHVlKSA9PiByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuZ2V0KHZhbHVlKTtcblxuZXhwb3J0IHsgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlIGFzIGEsIGluc3RhbmNlT2ZBbnkgYXMgaSwgcmVwbGFjZVRyYXBzIGFzIHIsIHVud3JhcCBhcyB1LCB3cmFwIGFzIHcgfTtcbiIsImltcG9ydCB7IHcgYXMgd3JhcCwgciBhcyByZXBsYWNlVHJhcHMgfSBmcm9tICcuL3dyYXAtaWRiLXZhbHVlLmpzJztcbmV4cG9ydCB7IHUgYXMgdW53cmFwLCB3IGFzIHdyYXAgfSBmcm9tICcuL3dyYXAtaWRiLXZhbHVlLmpzJztcblxuLyoqXG4gKiBPcGVuIGEgZGF0YWJhc2UuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgZGF0YWJhc2UuXG4gKiBAcGFyYW0gdmVyc2lvbiBTY2hlbWEgdmVyc2lvbi5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQWRkaXRpb25hbCBjYWxsYmFja3MuXG4gKi9cbmZ1bmN0aW9uIG9wZW5EQihuYW1lLCB2ZXJzaW9uLCB7IGJsb2NrZWQsIHVwZ3JhZGUsIGJsb2NraW5nLCB0ZXJtaW5hdGVkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihuYW1lLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBvcGVuUHJvbWlzZSA9IHdyYXAocmVxdWVzdCk7XG4gICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCd1cGdyYWRlbmVlZGVkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB1cGdyYWRlKHdyYXAocmVxdWVzdC5yZXN1bHQpLCBldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCB3cmFwKHJlcXVlc3QudHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChibG9ja2VkKVxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Jsb2NrZWQnLCAoKSA9PiBibG9ja2VkKCkpO1xuICAgIG9wZW5Qcm9taXNlXG4gICAgICAgIC50aGVuKChkYikgPT4ge1xuICAgICAgICBpZiAodGVybWluYXRlZClcbiAgICAgICAgICAgIGRiLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4gdGVybWluYXRlZCgpKTtcbiAgICAgICAgaWYgKGJsb2NraW5nKVxuICAgICAgICAgICAgZGIuYWRkRXZlbnRMaXN0ZW5lcigndmVyc2lvbmNoYW5nZScsICgpID0+IGJsb2NraW5nKCkpO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgIHJldHVybiBvcGVuUHJvbWlzZTtcbn1cbi8qKlxuICogRGVsZXRlIGEgZGF0YWJhc2UuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgZGF0YWJhc2UuXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZURCKG5hbWUsIHsgYmxvY2tlZCB9ID0ge30pIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKG5hbWUpO1xuICAgIGlmIChibG9ja2VkKVxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Jsb2NrZWQnLCAoKSA9PiBibG9ja2VkKCkpO1xuICAgIHJldHVybiB3cmFwKHJlcXVlc3QpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbn1cblxuY29uc3QgcmVhZE1ldGhvZHMgPSBbJ2dldCcsICdnZXRLZXknLCAnZ2V0QWxsJywgJ2dldEFsbEtleXMnLCAnY291bnQnXTtcbmNvbnN0IHdyaXRlTWV0aG9kcyA9IFsncHV0JywgJ2FkZCcsICdkZWxldGUnLCAnY2xlYXInXTtcbmNvbnN0IGNhY2hlZE1ldGhvZHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB7XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgSURCRGF0YWJhc2UgJiZcbiAgICAgICAgIShwcm9wIGluIHRhcmdldCkgJiZcbiAgICAgICAgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYWNoZWRNZXRob2RzLmdldChwcm9wKSlcbiAgICAgICAgcmV0dXJuIGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApO1xuICAgIGNvbnN0IHRhcmdldEZ1bmNOYW1lID0gcHJvcC5yZXBsYWNlKC9Gcm9tSW5kZXgkLywgJycpO1xuICAgIGNvbnN0IHVzZUluZGV4ID0gcHJvcCAhPT0gdGFyZ2V0RnVuY05hbWU7XG4gICAgY29uc3QgaXNXcml0ZSA9IHdyaXRlTWV0aG9kcy5pbmNsdWRlcyh0YXJnZXRGdW5jTmFtZSk7XG4gICAgaWYgKFxuICAgIC8vIEJhaWwgaWYgdGhlIHRhcmdldCBkb2Vzbid0IGV4aXN0IG9uIHRoZSB0YXJnZXQuIEVnLCBnZXRBbGwgaXNuJ3QgaW4gRWRnZS5cbiAgICAhKHRhcmdldEZ1bmNOYW1lIGluICh1c2VJbmRleCA/IElEQkluZGV4IDogSURCT2JqZWN0U3RvcmUpLnByb3RvdHlwZSkgfHxcbiAgICAgICAgIShpc1dyaXRlIHx8IHJlYWRNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyBmdW5jdGlvbiAoc3RvcmVOYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6IHVuZGVmaW5lZCBnemlwcHMgYmV0dGVyLCBidXQgZmFpbHMgaW4gRWRnZSA6KFxuICAgICAgICBjb25zdCB0eCA9IHRoaXMudHJhbnNhY3Rpb24oc3RvcmVOYW1lLCBpc1dyaXRlID8gJ3JlYWR3cml0ZScgOiAncmVhZG9ubHknKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IHR4LnN0b3JlO1xuICAgICAgICBpZiAodXNlSW5kZXgpXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaW5kZXgoYXJncy5zaGlmdCgpKTtcbiAgICAgICAgLy8gTXVzdCByZWplY3QgaWYgb3AgcmVqZWN0cy5cbiAgICAgICAgLy8gSWYgaXQncyBhIHdyaXRlIG9wZXJhdGlvbiwgbXVzdCByZWplY3QgaWYgdHguZG9uZSByZWplY3RzLlxuICAgICAgICAvLyBNdXN0IHJlamVjdCB3aXRoIG9wIHJlamVjdGlvbiBmaXJzdC5cbiAgICAgICAgLy8gTXVzdCByZXNvbHZlIHdpdGggb3AgdmFsdWUuXG4gICAgICAgIC8vIE11c3QgaGFuZGxlIGJvdGggcHJvbWlzZXMgKG5vIHVuaGFuZGxlZCByZWplY3Rpb25zKVxuICAgICAgICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRhcmdldFt0YXJnZXRGdW5jTmFtZV0oLi4uYXJncyksXG4gICAgICAgICAgICBpc1dyaXRlICYmIHR4LmRvbmUsXG4gICAgICAgIF0pKVswXTtcbiAgICB9O1xuICAgIGNhY2hlZE1ldGhvZHMuc2V0KHByb3AsIG1ldGhvZCk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbnJlcGxhY2VUcmFwcygob2xkVHJhcHMpID0+ICh7XG4gICAgLi4ub2xkVHJhcHMsXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4gZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpLFxuICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4gISFnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5oYXModGFyZ2V0LCBwcm9wKSxcbn0pKTtcblxuZXhwb3J0IHsgZGVsZXRlREIsIG9wZW5EQiB9O1xuIiwiaW1wb3J0IHsgb3BlbkRCIH0gZnJvbSAnaWRiJztcclxuXHJcbmNvbnN0IGRiUHJvbWlzZSA9IG9wZW5EQignamF0ZScsIDEsIHtcclxuICB1cGdyYWRlKGRiKSB7XHJcbiAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ2phdGUnKSkge1xyXG4gICAgICBjb25zdCBzdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdqYXRlJywgeyBrZXlQYXRoOiAnaWQnLCBhdXRvSW5jcmVtZW50OiB0cnVlIH0pO1xyXG4gICAgICBzdG9yZS5jcmVhdGVJbmRleCgnY29udGVudCcsICdjb250ZW50JywgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgICBjb25zb2xlLmxvZygnamF0ZSBkYXRhYmFzZSBjcmVhdGVkJyk7XHJcbiAgICB9XHJcbiAgfSxcclxufSk7XHJcbi8vIFRPRE86IEFkZCBsb2dpYyB0byBhIG1ldGhvZCB0aGF0IGFjY2VwdHMgc29tZSBjb250ZW50IGFuZCBhZGRzIGl0IHRvIHRoZSBkYXRhYmFzZSAtIGNvbXBsZXRlXHJcbmV4cG9ydCBjb25zdCBwdXREYiA9IGFzeW5jIChjb250ZW50KSA9PiB7XHJcbiAgY29uc3QgZGIgPSBhd2FpdCBkYlByb21pc2U7XHJcbiAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbignamF0ZScsICdyZWFkd3JpdGUnKTtcclxuICBjb25zdCBzdG9yZSA9IHR4Lm9iamVjdFN0b3JlKCdqYXRlJyk7XHJcbiAgYXdhaXQgc3RvcmUucHV0KHsgY29udGVudCB9KTtcclxuICBhd2FpdCB0eC5jb21wbGV0ZTtcclxuICBjb25zb2xlLmxvZygnQ29udGVudCBhZGRlZCB0byB0aGUgZGF0YWJhc2UnKTtcclxufTtcclxuLy8gVE9ETzogQWRkIGxvZ2ljIGZvciBhIG1ldGhvZCB0aGF0IGdldHMgYWxsIHRoZSBjb250ZW50IGZyb20gdGhlIGRhdGFiYXNlIC0gY29tcGxldGVcclxuZXhwb3J0IGNvbnN0IGdldERiID0gYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnN0IGRiID0gYXdhaXQgZGJQcm9taXNlO1xyXG4gIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oJ2phdGUnLCAncmVhZG9ubHknKTtcclxuICBjb25zdCBzdG9yZSA9IHR4Lm9iamVjdFN0b3JlKCdqYXRlJyk7XHJcbiAgY29uc3QgY29udGVudCA9IGF3YWl0IHN0b3JlLmdldEFsbCgpO1xyXG4gIGF3YWl0IHR4LmNvbXBsZXRlO1xyXG4gIHJldHVybiBjb250ZW50O1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZGJQcm9taXNlO1xyXG4iLCJjb25zdCBoZWFkZXIgPSBgXHJcbi8qXHJcbiAgICAgICBfX19fXyAgX19fX19fX19fX19fXHJcbiAgICAgIC8gLyAgIHwvXyAgX18vIF9fX18vXHJcbiBfXyAgLyAvIC98IHwgLyAvIC8gX18vICAgXHJcbi8gL18vIC8gX19fIHwvIC8gLyAvX19fICAgXHJcbiBfX19fL18vICB8Xy9fLyAvX19fX18vICAgXHJcbmp1c3QgYW5vdGhlciB0ZXh0IGVkaXRvclxyXG4qLyAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbmA7XHJcblxyXG5leHBvcnQgeyBoZWFkZXIgfTtcclxuIiwiLy8gSW1wb3J0IG1ldGhvZHMgdG8gc2F2ZSBhbmQgZ2V0IGRhdGEgZnJvbSB0aGUgaW5kZXhlZERCIGRhdGFiYXNlIGluICcuL2RhdGFiYXNlLmpzJ1xyXG5pbXBvcnQgeyBnZXREYiwgcHV0RGIgfSBmcm9tICcuL2RhdGFiYXNlJztcclxuaW1wb3J0IHsgaGVhZGVyIH0gZnJvbSAnLi9oZWFkZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgY29uc3QgbG9jYWxEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2NvbnRlbnQnKTtcclxuXHJcbiAgICAvLyBjaGVjayBpZiBDb2RlTWlycm9yIGlzIGxvYWRlZFxyXG4gICAgaWYgKHR5cGVvZiBDb2RlTWlycm9yID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVNaXJyb3IgaXMgbm90IGxvYWRlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZWRpdG9yID0gQ29kZU1pcnJvcihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbWFpbicpLCB7XHJcbiAgICAgIHZhbHVlOiAnJyxcclxuICAgICAgbW9kZTogJ2phdmFzY3JpcHQnLFxyXG4gICAgICB0aGVtZTogJ21vbm9rYWknLFxyXG4gICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcclxuICAgICAgbGluZVdyYXBwaW5nOiB0cnVlLFxyXG4gICAgICBhdXRvZm9jdXM6IHRydWUsXHJcbiAgICAgIGluZGVudFVuaXQ6IDIsXHJcbiAgICAgIHRhYlNpemU6IDIsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBXaGVuIHRoZSBlZGl0b3IgaXMgcmVhZHksIHNldCB0aGUgdmFsdWUgdG8gd2hhdGV2ZXIgaXMgc3RvcmVkIGluIGluZGV4ZWRkYi5cclxuICAgIC8vIEZhbGwgYmFjayB0byBsb2NhbFN0b3JhZ2UgaWYgbm90aGluZyBpcyBzdG9yZWQgaW4gaW5kZXhlZGRiLCBhbmQgaWYgbmVpdGhlciBpcyBhdmFpbGFibGUsIHNldCB0aGUgdmFsdWUgdG8gaGVhZGVyLlxyXG4gICAgZ2V0RGIoKS50aGVuKChkYXRhKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUuaW5mbygnTG9hZGVkIGRhdGEgZnJvbSBJbmRleGVkREIsIGluamVjdGluZyBpbnRvIGVkaXRvcicpO1xyXG4gICAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZShkYXRhIHx8IGxvY2FsRGF0YSB8fCBoZWFkZXIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5lZGl0b3Iub24oJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbnRlbnQnLCB0aGlzLmVkaXRvci5nZXRWYWx1ZSgpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNhdmUgdGhlIGNvbnRlbnQgb2YgdGhlIGVkaXRvciB3aGVuIHRoZSBlZGl0b3IgaXRzZWxmIGlzIGxvc2VzIGZvY3VzXHJcbiAgICB0aGlzLmVkaXRvci5vbignYmx1cicsICgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ1RoZSBlZGl0b3IgaGFzIGxvc3QgZm9jdXMnKTtcclxuICAgICAgcHV0RGIobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2NvbnRlbnQnKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgV29ya2JveCB9IGZyb20gJ3dvcmtib3gtd2luZG93L1dvcmtib3gubWpzJztcclxuaW1wb3J0IEVkaXRvciBmcm9tICcuL2VkaXRvcic7XHJcbmltcG9ydCAnLi9kYXRhYmFzZSc7XHJcbmltcG9ydCAnLi4vY3NzL3N0eWxlLmNzcyc7XHJcblxyXG5jb25zdCBtYWluID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21haW4nKTtcclxubWFpbi5pbm5lckhUTUwgPSAnJztcclxuXHJcbmNvbnN0IGxvYWRTcGlubmVyID0gKCkgPT4ge1xyXG4gIGNvbnN0IHNwaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBzcGlubmVyLmNsYXNzTGlzdC5hZGQoJ3NwaW5uZXInKTtcclxuICBzcGlubmVyLmlubmVySFRNTCA9IGBcclxuICA8ZGl2IGNsYXNzPVwibG9hZGluZy1jb250YWluZXJcIj5cclxuICA8ZGl2IGNsYXNzPVwibG9hZGluZy1zcGlubmVyXCIgLz5cclxuICA8L2Rpdj5cclxuICBgO1xyXG4gIG1haW4uYXBwZW5kQ2hpbGQoc3Bpbm5lcik7XHJcbn07XHJcblxyXG5jb25zdCBlZGl0b3IgPSBuZXcgRWRpdG9yKCk7XHJcblxyXG5pZiAodHlwZW9mIGVkaXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICBsb2FkU3Bpbm5lcigpO1xyXG59XHJcblxyXG4vLyBDaGVjayBpZiBzZXJ2aWNlIHdvcmtlcnMgYXJlIHN1cHBvcnRlZFxyXG5pZiAoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikge1xyXG4gIC8vIHJlZ2lzdGVyIHdvcmtib3ggc2VydmljZSB3b3JrZXJcclxuICBjb25zdCB3b3JrYm94U1cgPSBuZXcgV29ya2JveCgnLi4vLi4vc3JjLXN3LmpzJyk7XHJcbiAgd29ya2JveFNXLnJlZ2lzdGVyKCcuLi8uLi9zcmMtc3cuanMnKTtcclxufSBlbHNlIHtcclxuICBjb25zb2xlLmVycm9yKCdTZXJ2aWNlIHdvcmtlcnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLicpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJfcmVnZW5lcmF0b3JSdW50aW1lIiwiZXhwb3J0cyIsIk9wIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsImRlc2MiLCJ2YWx1ZSIsIiRTeW1ib2wiLCJTeW1ib2wiLCJpdGVyYXRvclN5bWJvbCIsIml0ZXJhdG9yIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsInRvU3RyaW5nVGFnIiwiZGVmaW5lIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZXJyIiwid3JhcCIsImlubmVyRm4iLCJvdXRlckZuIiwic2VsZiIsInRyeUxvY3NMaXN0IiwicHJvdG9HZW5lcmF0b3IiLCJHZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJjcmVhdGUiLCJjb250ZXh0IiwiQ29udGV4dCIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsImZuIiwiYXJnIiwidHlwZSIsImNhbGwiLCJDb250aW51ZVNlbnRpbmVsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwidmFsdWVzIiwiR3AiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJmb3JFYWNoIiwibWV0aG9kIiwiX2ludm9rZSIsIkFzeW5jSXRlcmF0b3IiLCJQcm9taXNlSW1wbCIsImludm9rZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWNvcmQiLCJyZXN1bHQiLCJfdHlwZW9mIiwiX19hd2FpdCIsInRoZW4iLCJ1bndyYXBwZWQiLCJlcnJvciIsInByZXZpb3VzUHJvbWlzZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwic3RhdGUiLCJFcnJvciIsImRvbmVSZXN1bHQiLCJkZWxlZ2F0ZSIsImRlbGVnYXRlUmVzdWx0IiwibWF5YmVJbnZva2VEZWxlZ2F0ZSIsInNlbnQiLCJfc2VudCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiYWJydXB0IiwiZG9uZSIsIm1ldGhvZE5hbWUiLCJ1bmRlZmluZWQiLCJUeXBlRXJyb3IiLCJpbmZvIiwicmVzdWx0TmFtZSIsIm5leHQiLCJuZXh0TG9jIiwicHVzaFRyeUVudHJ5IiwibG9jcyIsImVudHJ5IiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicHVzaCIsInJlc2V0VHJ5RW50cnkiLCJjb21wbGV0aW9uIiwicmVzZXQiLCJpdGVyYWJsZSIsIml0ZXJhdG9yTWV0aG9kIiwiaXNOYU4iLCJsZW5ndGgiLCJpIiwiZGlzcGxheU5hbWUiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiZ2VuRnVuIiwiY3RvciIsImNvbnN0cnVjdG9yIiwibmFtZSIsIm1hcmsiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImF3cmFwIiwiYXN5bmMiLCJQcm9taXNlIiwiaXRlciIsImtleXMiLCJ2YWwiLCJvYmplY3QiLCJyZXZlcnNlIiwicG9wIiwic2tpcFRlbXBSZXNldCIsInByZXYiLCJjaGFyQXQiLCJzbGljZSIsInN0b3AiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwiX2NhdGNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsIl9uZXh0IiwiX3Rocm93IiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJvcGVuREIiLCJkYlByb21pc2UiLCJ1cGdyYWRlIiwiZGIiLCJvYmplY3RTdG9yZU5hbWVzIiwiY29udGFpbnMiLCJzdG9yZSIsImNyZWF0ZU9iamVjdFN0b3JlIiwia2V5UGF0aCIsImF1dG9JbmNyZW1lbnQiLCJjcmVhdGVJbmRleCIsInVuaXF1ZSIsImNvbnNvbGUiLCJsb2ciLCJwdXREYiIsIl9yZWYiLCJfY2FsbGVlIiwiY29udGVudCIsInR4IiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInRyYW5zYWN0aW9uIiwib2JqZWN0U3RvcmUiLCJwdXQiLCJfeCIsImdldERiIiwiX3JlZjIiLCJfY2FsbGVlMiIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsImdldEFsbCIsImhlYWRlciIsIl9kZWZhdWx0IiwiX2NyZWF0ZUNsYXNzIiwiX3RoaXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJsb2NhbERhdGEiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiQ29kZU1pcnJvciIsImVkaXRvciIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIm1vZGUiLCJ0aGVtZSIsImxpbmVOdW1iZXJzIiwibGluZVdyYXBwaW5nIiwiYXV0b2ZvY3VzIiwiaW5kZW50VW5pdCIsInRhYlNpemUiLCJkYXRhIiwic2V0VmFsdWUiLCJvbiIsInNldEl0ZW0iLCJnZXRWYWx1ZSIsImRlZmF1bHQiLCJXb3JrYm94IiwiRWRpdG9yIiwibWFpbiIsImlubmVySFRNTCIsImxvYWRTcGlubmVyIiwic3Bpbm5lciIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJhcHBlbmRDaGlsZCIsIm5hdmlnYXRvciIsIndvcmtib3hTVyIsInJlZ2lzdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///773\n");

/***/ }),

/***/ 913:
/***/ (() => {

eval("\n// @ts-ignore\ntry {\n    self['workbox:core:6.5.4'] && _();\n}\ncatch (e) { }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0pBVEUvLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL192ZXJzaW9uLmpzPzA3MTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBAdHMtaWdub3JlXG50cnkge1xuICAgIHNlbGZbJ3dvcmtib3g6Y29yZTo2LjUuNCddICYmIF8oKTtcbn1cbmNhdGNoIChlKSB7IH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///913\n");

/***/ }),

/***/ 317:
/***/ (() => {

eval("\n// @ts-ignore\ntry {\n    self['workbox:window:6.5.4'] && _();\n}\ncatch (e) { }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE3LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0pBVEUvLi9ub2RlX21vZHVsZXMvd29ya2JveC13aW5kb3cvX3ZlcnNpb24uanM/YWZjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEB0cy1pZ25vcmVcbnRyeSB7XG4gICAgc2VsZlsnd29ya2JveDp3aW5kb3c6Ni41LjQnXSAmJiBfKCk7XG59XG5jYXRjaCAoZSkgeyB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///317\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__(773);
/******/ 	
/******/ })()
;